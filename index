<!-- ========== НАЧАЛО ЧАСТИ 1: HTML + БАЗОВЫЙ CSS ========== -->

<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>VATSIM AWOSD</title>
<style>
/* Базовые стили и layout */
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Segoe UI',sans-serif;background:#f0f0f0;transition:all .3s ease}
body.dark{background:#1a1a1a;color:#fff}
.container{padding:min(10px,1vw);margin:0 auto;height:100vh;display:flex;flex-direction:column;min-height:600px;max-height:100vh;overflow:hidden;max-width:100vw;box-sizing:border-box}
.controls{display:flex;gap:8px;margin-bottom:10px;align-items:center;flex-wrap:wrap;flex-shrink:0}
select,input{padding:4px 8px;border:1px solid #ccc;border-radius:4px;background:white;font-size:12px;height:28px}
.dark select,.dark input{background:#333;border-color:#555;color:white}
.main-layout{display:grid;grid-template-columns:35% 30% 35%;gap:min(10px,1vw);margin-bottom:min(10px,1vh);flex:1;min-height:0;max-width:100%}
.bottom-section{grid-column:1 / -1;flex:0 0 auto;height:clamp(100px,12vh,120px)}
.block{background:white;border-radius:6px;padding:min(12px,1vw);box-shadow:0 1px 5px rgba(0,0,0,.1);display:flex;flex-direction:column;overflow:hidden;min-height:0}
.dark .block{background:#2a2a2a;box-shadow:0 1px 5px rgba(255,255,255,.1)}

/* Статус подключения к данным */
.connection-status{display:flex;align-items:center;gap:5px;font-size:10px;color:#666}
.connection-status.connected{color:#28a745}
.connection-status.error{color:#dc3545}
.connection-status.loading{color:#ffc107}
.status-indicator{width:8px;height:8px;border-radius:50%;background:currentColor;animation:pulse 2s infinite}
.dark .connection-status{color:#999}
.dark .connection-status.connected{color:#40c767}
.dark .connection-status.error{color:#e74c3c}

@keyframes pulse {
0% { opacity: 1; }
50% { opacity: 0.5; }
100% { opacity: 1; }
}

/* Блок 1 - центральный */
.block-1{display:flex;flex-direction:column;align-items:center;text-align:center;gap:min(2px,.2vh);font-size:clamp(16px,1.6vw,22px);padding:min(6px,.6vw);overflow-y:auto}
.block-1 *{font-size:inherit!important}
.icao-section{text-align:center;margin-bottom:min(4px,.4vh)}
.block-1 .icao-input{text-align:center;width:clamp(140px,16vw,200px);font-size:clamp(16px,1.6vw,22px);height:clamp(28px,3vh,35px)}
.weather-data{display:flex;flex-direction:column;align-items:center;flex:1;gap:min(2px,.2vh);margin-top:min(20px,2vh)}
.weather-data>*{margin-bottom:0;flex-shrink:0}
.weather-data .sunrise-sunset-row{margin-bottom:min(24px,2.4vh)}
.weather-data .weather-row:first-of-type{margin-top:min(24px,2.4vh)}
.weather-row:nth-child(6){margin-top:min(24px,2.4vh)}
.weather-phenomena-block{margin-top:min(24px,2.4vh)}
.weather-phenomena-block+.weather-row{margin-top:min(24px,2.4vh)}
.weather-row:has(+ .weather-phenomena-block){margin-bottom:0}
.weather-row[id*=“mor”],.weather-row:has(.section-label:contains(“MOR”)){margin-top:min(24px,2.4vh)}
.cloudiness-block{margin-top:min(24px,2.4vh)}

/* Индикатор загрузки CSV данных */
.csv-loading{
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: rgba(0,0,0,0.8);
color: white;
padding: 20px;
border-radius: 8px;
z-index: 1000;
display: none;
text-align: center;
}

.csv-loading.show{
display: block;
}

.loading-spinner{
width: 40px;
height: 40px;
border: 4px solid #f3f3f3;
border-top: 4px solid #3498db;
border-radius: 50%;
animation: spin 1s linear infinite;
margin: 0 auto 10px;
}

@keyframes spin {
0% { transform: rotate(0deg); }
100% { transform: rotate(360deg); }
}

.csv-info{
font-size: 12px;
color: #ccc;
margin-top: 10px;
}
</style>

</head>
<body>
<div class="csv-loading" id="csvLoading">
  <div class="loading-spinner"></div>
  <div>Загрузка данных аэропортов...</div>
  <div class="csv-info">Обработка airports.csv и runways.csv</div>
</div>

<div class="container">
<div class="controls">
<select id="courseType">
<option value="true">True</option>
<option value="magnetic">Magnetic</option>
</select>
<select id="theme">
<option value="auto">Auto</option>
<option value="light">Light</option>
<option value="dark">Dark</option>
</select>
<select id="language">
<option value="en">English</option>
<option value="ru">Русский</option>
</select>
<div class="connection-status" id="connectionStatus">
<div class="status-indicator"></div>
<span>Ready to load local CSV files</span>
</div>
</div>

<div class="main-layout">
<!-- Блок компаса 1 -->
<div class="block">
        <div class="runway-selector">
<select id="runwaySelect">
<option value="">Enter ICAO code</option>
</select>
</div>
<div class="compass-container">
<div class="lateral-component">
<div class="data-value">-</div>
<div class="data-label" id="lateralLabel1">Side</div>
</div>
<div class="headwind-component">
<div class="data-value">-</div>
<div class="data-label" id="headwindLabel1">Head</div>
</div>
<div class="friction-coefficient">
<div class="data-value">-</div>
<div class="data-label" id="frictionLabel1">Breaking action</div>
</div>
<div class="compass" id="compass"></div>
<div class="wind-display">
<div class="wind-direction">---°</div>
<div class="wind-speed">-</div>
<div class="wind-unit">kt</div>
</div>
</div>
<div class="compass-info">
<div class="rvr-row">
<div class="section-label">RVR</div>
<div class="data-field">
<div class="data-value">-</div>
</div>
<div class="units">м</div>
</div>
</div>
</div>

<!-- Центральный блок -->

<div class="block block-1">
<div class="icao-section">
<input type="text" id="icaoInput" class="icao-input" placeholder="ICAO" maxlength="4">
</div>
<div class="weather-data">
<div class="section-label" id="timeLabel">Time UTC</div>
<div class="data-field">
<div class="data-value" id="currentTime">--:--</div>
</div>
<div class="sunrise-sunset-row">
<div class="sunrise-sunset-item">
<div class="section-label" id="sunriseLabel">Sunrise</div>
<div class="data-field">
<div class="data-value" id="sunrise">-</div>
</div>
</div>
<div class="sunrise-sunset-item">
<div class="section-label" id="sunsetLabel">Sunset</div>
<div class="data-field">
<div class="data-value" id="sunset">-</div>
</div>
</div>
</div>
<div class="weather-row">
<div class="section-label">QNH</div>
<div class="data-field">
<div class="data-value">-</div>
</div>
<div class="units">hPa</div>
</div>
<div class="weather-row pressure-row">
<div class="section-label"></div>
<div class="data-field">
<div class="data-value pressure-secondary">-</div>
</div>
<div class="units">mmHg</div>
</div>
<div class="weather-row pressure-row">
<div class="section-label"></div>
<div class="data-field">
<div class="data-value pressure-secondary">-</div>
</div>
<div class="units">inHg</div>
</div>
<div class="weather-row">
<div class="section-label">T</div>
<div class="data-field">
<div class="data-value">-</div>
</div>
<div class="units">°C</div>
</div>
<div class="weather-row">
<div class="section-label">DP</div>
<div class="data-field">
<div class="data-value">-</div>
</div>
<div class="units">°C</div>
</div>
<div class="weather-phenomena-block">
<div class="section-label" id="weatherLabel">Weather</div>
<div class="data-field">
<div class="data-value" id="weatherPhenomena">-</div>
</div>
</div>
<div class="weather-row">
<div class="section-label" id="morLabel">MOR</div>
<div class="data-field">
<div class="data-value">-</div>
</div>
<div class="units">м</div>
</div>
<div class="weather-row">
<div class="section-label" id="qbbLabel">QBB</div>
<div class="data-field">
<div class="data-value">-</div>
</div>
<div class="units">м</div>
</div>
<div class="cloudiness-block">
<div class="section-label" id="skyConditionLabel">Sky condition</div>
<div class="data-field">
<div class="data-value">-</div>
</div>
</div>
</div>
</div>

<!-- Блок компаса 2 -->

<div class="block">
        <div class="runway-selector">
<div class="runway-display-label" id="runwayDisplay2">--</div>
</div>
<div class="compass-container">
<div class="lateral-component">
<div class="data-value">-</div>
<div class="data-label" id="lateralLabel2">Side</div>
</div>
<div class="headwind-component">
<div class="data-value">-</div>
<div class="data-label" id="headwindLabel2">Head</div>
</div>
<div class="friction-coefficient">
<div class="data-value">-</div>
<div class="data-label" id="frictionLabel2">Breaking action</div>
</div>
<div class="compass" id="compass2"></div>
<div class="wind-display">
<div class="wind-direction">---°</div>
<div class="wind-speed">-</div>
<div class="wind-unit">kt</div>
</div>
</div>
<div class="compass-info">
<div class="rvr-row">
<div class="section-label">RVR</div>
<div class="data-field">
<div class="data-value">-</div>
</div>
<div class="units">м</div>
</div>
</div>
</div>

<!-- Нижний блок -->

<div class="bottom-section">
<div class="forecast-section">
<div class="forecast-field">
<div class="forecast-label" id="forecastLabel">Weather forecast</div>
<div class="forecast-value">-</div>
</div>
<div class="forecast-field">
<div class="forecast-label" id="specialLabel">Special conditions</div>
<div class="forecast-value">-</div>
</div>
<div class="forecast-field">
<div class="forecast-label">METAR</div>
<div class="forecast-value" id="metarCode">-</div>
</div>
</div>
</div>
</div>
</div>

<!-- ========== КОНЕЦ ЧАСТИ 1 ========== --><!-- ========== ЗАМЕНА ЧАСТИ 2 CSS: ГОРИЗОНТАЛЬНЫЙ LAYOUT COMPASS-INFO ========== -->

<style>
/* Продолжение стилей из части 1 */
.sunrise-sunset-row{display:flex;gap:min(6px,.6vw);align-items:center;margin-bottom:min(4px,.4vh)}
.sunrise-sunset-item{display:flex;flex-direction:column;align-items:center;gap:1px}

/* УМЕНЬШЕННЫЙ БЛОК ВРЕМЕНИ НА 20% */
.sunrise-sunset-item .section-label{font-size:clamp(11px,1.1vw,14px)!important}
.sunrise-sunset-item .data-field{width:clamp(72px,7.2vw,104px);font-size:clamp(13px,1.3vw,18px)!important}
.sunrise-sunset-item .data-value{font-size:clamp(13px,1.3vw,18px)!important}

/* ВЫРАВНИВАНИЕ ПОЛЕЙ ПОГОДЫ ПО ЦЕНТРАЛЬНОЙ ЛИНИИ */
.weather-row{
display:grid;
grid-template-columns:1fr auto 1fr;
align-items:center;
width:100%;
gap:min(6px,.6vw);
margin:min(4px,.4vh) 0;
}

.weather-row .section-label{
color:#666;
text-align:right;
font-size:clamp(14px,1.4vw,18px);
white-space:nowrap;
justify-self:end;
}

.weather-row .data-field{
width:max(80px,7vw);
text-align:center;
padding:min(4px,.4vw);
background:#f8f8f8;
border-radius:3px;
justify-self:center;
}

.weather-row .units{
color:#666;
text-align:left;
font-size:clamp(14px,1.4vw,18px);
justify-self:start;
}

/* ========== РАСШИРЕННЫЕ БЛОКИ ЯВЛЕНИЙ ПОГОДЫ И ОБЛАЧНОСТИ НА 60% ========== */
.weather-phenomena-block,.cloudiness-block{
width:100%;
text-align:center;
display:flex;
flex-direction:column;
align-items:center;
margin:min(8px,.8vh) 0
}

.weather-phenomena-block .section-label,.cloudiness-block .section-label{
text-align:center!important;
width:100%!important;
margin-bottom:min(5px,.5vh)!important
}

.weather-phenomena-block .data-field,.cloudiness-block .data-field{
width:clamp(288px,28.8vw,448px)!important;
text-align:center!important
}

/* ИСПРАВЛЯЕМ ШРИФТ ЯВЛЕНИЙ И ОБЛАЧНОСТИ - КАК У ВОСХОДА/ЗАХОДА */
.weather-phenomena-block .data-value,.cloudiness-block .data-value{
font-weight:normal!important;
font-size:clamp(13px,1.3vw,18px)!important;
}

/* СТИЛИ ДЛЯ ПОЛЕЙ QNH С УМЕНЬШЕННЫМ ШРИФТОМ И ОТСТУПАМИ */
.weather-row+.weather-row.pressure-row{margin-top:min(-6px,-.6vh)}
.weather-row.pressure-row .section-label{font-size:clamp(10px,1.0vw,13px)!important}
.weather-row.pressure-row .data-field{font-size:clamp(10px,1.0vw,13px)!important}
.weather-row.pressure-row .units{font-size:clamp(10px,1.0vw,13px)!important}
.weather-row.pressure-row .data-value{font-size:clamp(11px,1.1vw,14px)!important}

/* ОТСТУП ПОСЛЕ ПОСЛЕДНЕГО ПОЛЯ QNH */
.weather-row:nth-child(6){margin-bottom:min(24px,2.4vh)!important}
.weather-row.pressure-row:last-of-type{margin-bottom:min(24px,2.4vh)!important}
.weather-row.pressure-row:nth-child(3){margin-bottom:min(24px,2.4vh)!important}
.weather-row:has(.units:contains("inHg")){margin-bottom:min(24px,2.4vh)!important}
.weather-row .units:contains("inHg"){margin-bottom:min(24px,2.4vh)!important}

.dark .weather-row .section-label,.dark .weather-row .units{color:#ccc}
.block-1 .section-label{color:#666;margin-bottom:1px;font-size:clamp(14px,1.4vw,18px);text-align:center}
.dark .block-1 .section-label{color:#ccc}
.block-1 .data-field{width:clamp(110px,11vw,150px);text-align:center;padding:min(4px,.4vw);background:#f8f8f8;border-radius:3px}
.data-field{text-align:center;padding:min(4px,.5vw);background:#f8f8f8;border-radius:3px}
.dark .data-field{background:#333}
.data-label{font-size:clamp(10px,1vw,12px);color:#666;margin-bottom:2px}
.dark .data-label{color:#ccc}
.data-value{font-size:clamp(16px,1.6vw,22px);font-weight:bold;line-height:.9}
#currentTime,#sunrise,#sunset{font-weight:normal!important}
.pressure-secondary{font-weight:normal!important}

/* Стили компаса */
.compass-container{position:relative;width:80%;aspect-ratio:1;margin:0 auto 80px auto;flex-shrink:0;margin-top:min(30px,3vh);overflow:visible}
.compass{position:relative;width:100%;height:100%;border:2px solid #333;border-radius:50%;background:radial-gradient(circle,#fff 0%,#f0f0f0 100%);overflow:visible}
.dark .compass{border-color:#666;background:radial-gradient(circle,#2a2a2a 0%,#1a1a1a 100%)}
.compass-mark{position:absolute;background:#333}
.compass-mark.minor{width:1px;height:12px}
.compass-mark.major{width:2px;height:18px}
.dark .compass-mark{background:#ccc}
.compass-number{position:absolute;font-size:clamp(12px,1.8vw,20px);font-weight:bold;width:24px;text-align:center}
.wind-display{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;background:rgba(255,255,255,.9);padding:min(8px,.8vw);border-radius:6px;border:1px solid #ccc;min-width:80px}
.dark .wind-display{background:rgba(42,42,42,.9);border-color:#555}
.wind-direction{font-size:clamp(18px,2vw,26px);font-weight:bold}
.wind-speed{font-size:clamp(16px,1.8vw,22px);color:#333}
.dark .wind-speed{color:#ccc}
.wind-unit{font-size:clamp(12px,1.2vw,16px);color:#666}

/* Стили ВПП */
.runway-display{position:absolute;top:50%;left:50%;width:70%;height:24px;background:transparent;border:3px solid #333;transform:translate(-50%,-50%);border-radius:6px}
.dark .runway-display{border-color:#ccc}
.runway-display.left-landing::before{content:'';position:absolute;width:20%;height:2px;background:repeating-linear-gradient(to right,#333 0px,#333 4px,transparent 4px,transparent 8px);left:5%;top:50%;transform:translateY(-50%);z-index:16}
.runway-display.left-landing::after{content:'';position:absolute;width:0;height:0;border-left:8px solid #333;border-top:4px solid transparent;border-bottom:4px solid transparent;left:25%;top:50%;transform:translateY(-50%);z-index:16}
.runway-display.right-landing::before{content:'';position:absolute;width:20%;height:2px;background:repeating-linear-gradient(to left,#333 0px,#333 4px,transparent 4px,transparent 8px);right:5%;top:50%;transform:translateY(-50%);z-index:16}
.runway-display.right-landing::after{content:'';position:absolute;width:0;height:0;border-right:8px solid #333;border-top:4px solid transparent;border-bottom:4px solid transparent;right:25%;top:50%;transform:translateY(-50%);z-index:16}
.dark .runway-display.left-landing::before{background:repeating-linear-gradient(to right,#ccc 0px,#ccc 4px,transparent 4px,transparent 8px)}
.dark .runway-display.right-landing::before{background:repeating-linear-gradient(to left,#ccc 0px,#ccc 4px,transparent 4px,transparent 8px)}
.dark .runway-display.left-landing::after{border-left-color:#ccc}
.dark .runway-display.right-landing::after{border-right-color:#ccc}

/* Стили ветра */
.wind-arrow{position:absolute;width:4px;height:25%;background:#333;transform-origin:top center;z-index:10}
.wind-arrow::after{content:'';position:absolute;bottom:-8px;left:50%;transform:translateX(-50%);width:0;height:0;border-left:8px solid transparent;border-right:8px solid transparent;border-top:10px solid #333}
.dark .wind-arrow{background:#ccc}
.dark .wind-arrow::after{border-top-color:#ccc}
.wind-sector{position:absolute;top:50%;left:50%;width:0;height:0;border-left:60px solid transparent;border-right:60px solid transparent;border-bottom:60px solid rgba(255,107,107,.3);transform:translate(-50%,-100%) rotate(180deg);transform-origin:bottom center;display:none}
.wind-sector.variable{display:block}

/* ========== ГОРИЗОНТАЛЬНЫЙ LAYOUT ДЛЯ COMPASS-INFO: ЗАГОЛОВКИ СЛЕВА, ЕДИНИЦЫ СПРАВА ========== */
.compass-info{
display:grid;
grid-template-columns: 40% 60%; /* Левая колонка уже, правая шире для QFE */
grid-template-rows: auto auto;
gap:min(8px,0.8vw);
margin-top:min(5px,0.5vh);
font-size:clamp(10px,1vw,14px);
margin-bottom:min(5px,.5vh);
width:100%;
}

/* ========== RVR - ЛЕВАЯ ВЕРХНЯЯ ПОЗИЦИЯ (ГОРИЗОНТАЛЬНЫЙ LAYOUT) ========== */
.rvr-row{
grid-column: 1;
grid-row: 1;
display:grid;
grid-template-columns: 1fr auto 1fr; /* Заголовок | Значение | Единицы */
align-items:center;
gap:min(4px,.4vw);
}

.rvr-row .section-label{
color:#666;
font-size:clamp(12px,1.2vw,16px);
text-align:right;
justify-self:end;
}

.rvr-row .data-field{
width:max(60px,6vw);
text-align:center;
padding:min(3px,.3vw);
background:#f8f8f8;
border-radius:3px;
justify-self:center;
}

.rvr-row .units{
color:#666;
font-size:clamp(12px,1.2vw,16px);
text-align:left;
justify-self:start;
}

/* ========== ELEVATION - ЛЕВАЯ НИЖНЯЯ ПОЗИЦИЯ (ГОРИЗОНТАЛЬНЫЙ LAYOUT) ========== */
.elev-row{
grid-column: 1;
grid-row: 2;
display:grid;
grid-template-columns: 1fr auto 1fr; /* Заголовок | Значение | Единицы */
align-items:center;
gap:min(4px,.4vw);
}

.elev-row .section-label{
color:#666;
font-size:clamp(12px,1.2vw,16px);
text-align:right;
justify-self:end;
}

.elev-row .data-field{
width:max(60px,6vw);
text-align:center;
padding:min(3px,.3vw);
background:#f8f8f8;
border-radius:3px;
justify-self:center;
}

.elev-row .units{
color:#666;
font-size:clamp(12px,1.2vw,16px);
text-align:left;
justify-self:start;
}

/* ========== QFE - ПРАВАЯ КОЛОНКА (ВЕРТИКАЛЬНЫЙ LAYOUT КАК QNH) ========== */
.qfe-row{
grid-column: 2;
grid-row: 1 / span 2; /* Занимает обе строки */
display:flex;
flex-direction:column;
align-items:center;
gap:2px;
justify-content:center;
}

.qfe-row .section-label{
color:#666;
font-size:clamp(12px,1.2vw,16px);
text-align:center;
margin-bottom:3px;
}

/* QFE поля данных - как у QNH (горизонтальный layout для каждого поля) */
.qfe-row .qfe-field{
display:grid;
grid-template-columns: 1fr auto 1fr; /* Пустое | Значение | Единицы */
align-items:center;
gap:min(4px,.4vw);
margin-bottom:3px;
width:100%;
}

.qfe-row .qfe-field .data-field{
width:max(65px,6.5vw);
text-align:center;
padding:min(2px,.2vw);
background:#f8f8f8;
border-radius:3px;
justify-self:center;
}

.qfe-row .qfe-field .units{
color:#666;
font-size:clamp(10px,1.0vw,13px);
text-align:left;
justify-self:start;
}

.qfe-row .qfe-field .data-value{
font-size:clamp(11px,1.1vw,14px);
font-weight:normal;
}

.qfe-row .qfe-field.secondary .data-value{
font-weight:normal;
}

/* ДАННЫЕ В ПОЛЯХ */
.rvr-row .data-field .data-value,
.elev-row .data-field .data-value{
font-size:clamp(12px,1.2vw,16px);
font-weight:bold;
}

/* ТЕМНАЯ ТЕМА */
.dark .rvr-row .section-label,
.dark .elev-row .section-label,
.dark .qfe-row .section-label,
.dark .rvr-row .units,
.dark .elev-row .units,
.dark .qfe-row .qfe-field .units{
color:#ccc;
}

.dark .rvr-row .data-field,
.dark .elev-row .data-field,
.dark .qfe-row .qfe-field .data-field{
background:#333;
}

/* Компоненты ветра */
.lateral-component{position:absolute;top:-30px;left:-45px;font-size:clamp(10px,1vw,12px);background:#f8f8f8;padding:2px 6px;border-radius:3px;z-index:5;width:max(50px,5vw);text-align:center}
.lateral-component .data-label{position:absolute;top:100%;left:50%;transform:translateX(-50%);margin-top:2px;background:transparent;font-size:clamp(8px,0.8vw,10px)}
.headwind-component{position:absolute;top:-30px;right:-45px;font-size:clamp(10px,1vw,12px);background:#f8f8f8;padding:2px 6px;border-radius:3px;z-index:5;width:max(50px,5vw);text-align:center}
.headwind-component .data-label{position:absolute;top:100%;left:50%;transform:translateX(-50%);margin-top:2px;background:transparent;font-size:clamp(8px,0.8vw,10px)}
.friction-coefficient{position:absolute;bottom:-30px;right:-45px;font-size:clamp(10px,1vw,12px);background:#f8f8f8;padding:2px 6px;border-radius:3px;z-index:5;width:max(50px,5vw);text-align:center}
.friction-coefficient .data-label{position:absolute;bottom:100%;left:50%;transform:translateX(-50%);margin-bottom:2px;background:transparent;font-size:clamp(8px,0.8vw,10px)}
.dark .lateral-component,.dark .headwind-component,.dark .friction-coefficient{background:#333;color:#ccc}

/* Прогноз погоды */
.forecast-section{background:white;border-radius:6px;padding:min(8px,.8vw);box-shadow:0 1px 5px rgba(0,0,0,.1);height:100%;overflow:hidden;font-size:clamp(10px,1vw,12px);display:flex;flex-direction:column;justify-content:space-between}
.dark .forecast-section{background:#2a2a2a;box-shadow:0 1px 5px rgba(255,255,255,.1)}
.forecast-field{margin:2px 0;padding:0;background:transparent;border-radius:0;display:flex;align-items:center;gap:8px}
.forecast-field .forecast-label{color:#666;min-width:max(100px,10vw);text-align:right;font-size:clamp(10px,1vw,12px);font-weight:normal;margin-right:min(4px,.4vw)}
.forecast-field .forecast-value{flex:1;background:#f8f8f8;padding:3px 6px;border-radius:3px;font-size:clamp(10px,1vw,12px);word-break:break-all}
.dark .forecast-field .forecast-label{color:#ccc}
.dark .forecast-field .forecast-value{background:#333}

/* Селектор ВПП */
.runway-selector{margin-bottom:min(10px,1vh);display:flex;justify-content:center}
.runway-selector select,.runway-display-label{text-align:center;width:clamp(140px,16vw,200px);font-size:clamp(12px,1.4vw,16px);height:clamp(28px,3vh,35px);padding:2px 6px;border:1px solid #ccc;border-radius:4px;background:white}
.runway-display-label{display:flex;align-items:center;justify-content:center;font-weight:bold;color:#333}
.dark .runway-selector select,.dark .runway-display-label{background:#333;border-color:#555;color:white}

/* Стрелки трендов */
.trend-arrow{display:inline-block;margin-left:3px;font-size:14px;color:#666}
.block-1 .trend-arrow{margin-left:5px}
.trend-up{color:#28a745}
.trend-down{color:#dc3545}
.dark .trend-arrow{color:#999}

/* Медиа-запросы С ВОЗВРАЩЕННЫМИ ПРОПОРЦИЯМИ */
@media (max-width:1400px){.main-layout{grid-template-columns:34% 32% 34%}}
@media (max-width:1200px){.main-layout{grid-template-columns:32% 36% 32%}}
@media (max-width:900px){.main-layout{grid-template-columns:30% 40% 30%;gap:min(6px,1vh)}.container{padding:min(6px,1vw)}.block{padding:min(8px,1.2vw)}.compass-container{width:75%;margin-bottom:10px}}
@media (max-width:600px){.main-layout{grid-template-columns:28% 44% 28%;gap:min(4px,.6vh)}.block{padding:min(6px,1vw)}.compass-container{width:70%;margin-bottom:8px}}
</style>

<!-- ========== КОНЕЦ ЧАСТИ 2 ========== --><!-- ========== ЧАСТЬ 3: ПОЛНЫЙ OURAIRPORTS API С ИСПРАВЛЕННЫМ QFE ========== -->

<script>
// Глобальные переменные
let currentMetarData = null;
let currentRunwayData = null;
let updateInterval = null;
let globalAPI = null;

// OurAirports API для работы ТОЛЬКО с локальными CSV файлами - ИСПРАВЛЕННЫЙ QFE
class OurAirportsAPI {
  constructor() {
    this.airports = new Map();
    this.loaded = false;
    this.loadingPromise = null;
  }

  async loadDatabase() {
    if (this.loaded) return true;

    if (this.loadingPromise) return this.loadingPromise;

    console.log('🔄 Загружаем локальные CSV файлы...');
    this.showCSVLoading(true);
    updateConnectionStatus('loading', 'Loading local CSV files...');

    this.loadingPromise = this._loadLocalCSVFiles();
    return this.loadingPromise;
  }

  async _loadLocalCSVFiles() {
    try {
      console.log('📥 Loading local airports.csv and runways.csv...');

      // Загружаем ТОЛЬКО локальные файлы
      const [airportsResponse, runwaysResponse] = await Promise.all([
        fetch('./airports.csv'),
        fetch('./runways.csv')
      ]);

      if (!airportsResponse.ok) {
        throw new Error(`Cannot load airports.csv: ${airportsResponse.status} ${airportsResponse.statusText}`);
      }

      if (!runwaysResponse.ok) {
        throw new Error(`Cannot load runways.csv: ${runwaysResponse.status} ${runwaysResponse.statusText}`);
      }

      const airportsData = await airportsResponse.text();
      const runwaysData = await runwaysResponse.text();

      console.log(`✅ Loaded local CSV files successfully`);
      console.log(`📊 File sizes: airports=${Math.round(airportsData.length/1024)}KB, runways=${Math.round(runwaysData.length/1024)}KB`);

      // Проверяем что файлы не пустые и содержат заголовки
      if (airportsData.length < 100) {
        throw new Error('airports.csv appears to be empty or too small');
      }
      if (runwaysData.length < 100) {
        throw new Error('runways.csv appears to be empty or too small');
      }

      // Проверяем заголовки CSV
      const airportsFirstLine = airportsData.split('\n')[0];
      const runwaysFirstLine = runwaysData.split('\n')[0];

      if (!airportsFirstLine.includes('ident') || !airportsFirstLine.includes('name')) {
        throw new Error('airports.csv does not appear to have correct format');
      }
      if (!runwaysFirstLine.includes('airport_ident') || !runwaysFirstLine.includes('le_ident')) {
        throw new Error('runways.csv does not appear to have correct format');
      }

      console.log('✅ CSV files validation passed');

      // Парсим CSV данные
      await this._parseCSVData(airportsData, runwaysData);

      this.loaded = true;
      this.showCSVLoading(false);

      const stats = {
        airports: this.airports.size,
        totalRunways: Array.from(this.airports.values()).reduce((sum, airport) => sum + airport.runways.length, 0)
      };

      console.log(`✅ Processed ${stats.airports} airports with ${stats.totalRunways} runways from local CSV files`);
      updateConnectionStatus('connected', `${stats.airports} airports loaded from CSV`);

      return true;

    } catch (error) {
      console.error('❌ Failed to load local CSV files:', error);
      console.error('💡 Make sure:');
      console.error('   1. airports.csv and runways.csv are in the same folder as index.html');
      console.error('   2. You are accessing via HTTP server (http://localhost) not file:// protocol');
      console.error('   3. Files are downloaded from https://ourairports.com/data/');

      this.showCSVLoading(false);
      updateConnectionStatus('error', 'CSV files required - cannot load airport data');

      console.log('❌ CSV files are required for operation');
      throw new Error('CSV files are required - place airports.csv and runways.csv in the same folder');
    }
  }

  async _parseCSVData(airportsCSV, runwaysCSV) {
    console.log('📊 Parsing CSV data...');

    // Простой CSV парсер
    const parseCSV = (text) => {
      const lines = text.split('\n');
      const headers = this._parseCSVLine(lines[0]);
      const data = [];

      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        const values = this._parseCSVLine(line);
        if (values.length >= headers.length) {
          const row = {};
          headers.forEach((header, index) => {
            row[header] = values[index] || '';
          });
          data.push(row);
        }
      }
      return data;
    };

    // Парсим аэропорты
    console.log('  📄 Parsing airports...');
    const airportsData = parseCSV(airportsCSV);
    let airportCount = 0;

    for (const row of airportsData) {
      const icao = row.ident;

      // Только ICAO коды (4 символа)
      if (!icao || icao.length !== 4 || !icao.match(/^[A-Z0-9]{4}$/)) continue;

      // Пропускаем закрытые аэропорты
      if (row.type === 'closed') continue;

      try {
        // РАСШИРЕННЫЕ ДАННЫЕ АЭРОПОРТА С РЕГИОНАМИ
        this.airports.set(icao, {
          icao: icao,
          name: row.name || 'Unknown Airport',
          type: row.type || 'unknown',
          elevation_ft: parseFloat(row.elevation_ft) || 0,
          latitude: parseFloat(row.latitude_deg) || 0,
          longitude: parseFloat(row.longitude_deg) || 0,

          // РЕГИОНАЛЬНЫЕ ДАННЫЕ ДЛЯ ЧАСОВЫХ ПОЯСОВ
          country: row.iso_country || '',
          iso_country: row.iso_country || '',
          iso_region: row.iso_region || '',
          municipality: row.municipality || '',
          continent: row.continent || '',

          // Дополнительные поля
          iata: row.iata_code || null,
          local_code: row.local_code || null,
          gps_code: row.gps_code || null,
          home_link: row.home_link || null,
          wikipedia_link: row.wikipedia_link || null,
          keywords: row.keywords || '',

          runways: []
        });
        airportCount++;

        // Прогресс каждые 10000 аэропортов
        if (airportCount % 10000 === 0) {
          console.log(`    Processed ${airportCount} airports...`);
        }
      } catch (error) {
        continue;
      }
    }

    console.log(`    ✅ Processed ${airportCount} airports with regional data`);

    // Парсим ВПП
    console.log('  🛬 Parsing runways...');
    const runwaysData = parseCSV(runwaysCSV);
    let runwayCount = 0;

    for (const row of runwaysData) {
      const icao = row.airport_ident;

      if (!this.airports.has(icao)) continue;
      if (row.closed === '1') continue;

      try {
        const runway = {
          le_ident: row.le_ident || '',
          he_ident: row.he_ident || '',
          le_elevation_ft: parseFloat(row.le_elevation_ft) || 0,
          he_elevation_ft: parseFloat(row.he_elevation_ft) || 0,
          le_heading_deg: parseFloat(row.le_heading_degT) || 0,
          he_heading_deg: parseFloat(row.he_heading_degT) || 180,
          length_ft: parseFloat(row.length_ft) || 0,
          width_ft: parseFloat(row.width_ft) || 0,
          surface: row.surface || 'ASP'
        };

        this.airports.get(icao).runways.push(runway);
        runwayCount++;

        // Прогресс каждые 5000 ВПП
        if (runwayCount % 5000 === 0) {
          console.log(`    Processed ${runwayCount} runways...`);
        }
      } catch (error) {
        continue;
      }
    }

    console.log(`    ✅ Processed ${runwayCount} runways`);

    // Удаляем аэропорты без ВПП
    const airportsWithRunways = new Map();
    for (const [icao, airport] of this.airports) {
      if (airport.runways && airport.runways.length > 0) {
        airportsWithRunways.set(icao, airport);
      }
    }
    this.airports = airportsWithRunways;

    console.log(`📊 Final: ${this.airports.size} airports with runways and regional data`);
  }

  _parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
      const char = line[i];

      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }

    result.push(current.trim());
    return result.map(val => val.replace(/^"|"$/g, ''));
  }

  showCSVLoading(show) {
    const loader = document.getElementById('csvLoading');
    if (loader) {
      loader.className = show ? 'csv-loading show' : 'csv-loading';
    }
  }

  async getRunwayData(icao) {
    await this.loadDatabase();

    const airport = this.airports.get(icao.toUpperCase());
    if (!airport || !airport.runways || airport.runways.length === 0) {
      throw new Error(`No runway data for ${icao}`);
    }

    console.log(`✅ Found ${airport.runways.length} runways for ${icao} (${airport.name}) in ${airport.iso_region || airport.country}`);

    // Конвертируем в нужный формат
    return airport.runways.map(runway => ({
      leIdent: runway.le_ident,
      heIdent: runway.he_ident,
      leElevation: runway.le_elevation_ft * 0.3048, // футы в метры
      heElevation: runway.he_elevation_ft * 0.3048,
      leHeading: runway.le_heading_deg,
      heHeading: runway.he_heading_deg,
      length: runway.length_ft * 0.3048,
      width: runway.width_ft * 0.3048,
      surface: runway.surface
    }));
  }

  getRunwayElevation(runwayData, selectedRunway) {
    for (const runway of runwayData) {
      if (runway.leIdent === selectedRunway) return runway.leElevation;
      if (runway.heIdent === selectedRunway) return runway.heElevation;
    }
    return null;
  }

  // ========== ИСПРАВЛЕННЫЙ РАСЧЕТ QFE ==========
  calculateQFE(qnhHpa, elevationMeters) {
    if (!qnhHpa || elevationMeters === null) return null;

    // ИСПРАВЛЕННАЯ ФОРМУЛА: QFE = QNH - (высота_в_метрах / 8.5)
    // Стандартная формула ИКАО: на каждые 8.5 метров высоты давление падает на 1 гПа
    const qfe = qnhHpa - (elevationMeters / 8.5);

    console.log(`🔧 QFE calculation FIXED: QNH ${qnhHpa} hPa - elevation ${elevationMeters}m / 8.5 = ${Math.round(qfe)} hPa`);

    return Math.round(qfe);
  }

  // НОВЫЙ МЕТОД ДЛЯ ПОЛУЧЕНИЯ ДАННЫХ АЭРОПОРТА С РЕГИОНАЛЬНОЙ ИНФОРМАЦИЕЙ
  getAirportInfo(icao) {
    const airport = this.airports.get(icao.toUpperCase());
    if (!airport) return null;

    return {
      icao: airport.icao,
      name: airport.name,
      latitude: airport.latitude,
      longitude: airport.longitude,
      country: airport.country,
      iso_region: airport.iso_region,
      municipality: airport.municipality,
      continent: airport.continent,
      elevation_ft: airport.elevation_ft
    };
  }
}

// METAR парсер (без изменений)
function parseMetar(metarString) {
  if (!metarString) return null;

  const parts = metarString.split(' ');
  const data = {
    raw: metarString,
    icao: parts[0],
    time: '',
    wind: { direction: 0, speed: 0, gust: 0, variable: false, calm: false },
    visibility: 0,
    weather: [],
    clouds: [],
    temperature: null,
    dewpoint: null,
    pressure: 0
  };

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];

    // Время
    if (part.match(/^\d{6}Z$/)) {
      data.time = part;
    }

    // Ветер
    if (part.match(/^\d{3}\d{2}(G\d{2})?KT$/)) {
      data.wind.direction = parseInt(part.substring(0, 3));
      data.wind.speed = parseInt(part.substring(3, 5));
      const gustMatch = part.match(/G(\d{2})/);
      data.wind.gust = gustMatch ? parseInt(gustMatch[1]) : 0;
    }

    // Штиль
    if (part === '00000KT') {
      data.wind.calm = true;
    }

    // Переменный ветер
    if (part.match(/^\d{3}V\d{3}$/)) {
      data.wind.variable = true;
    }

    // Видимость
    if (part.match(/^\d{4}$/) && parseInt(part) > 100) {
      data.visibility = parseInt(part);
    }

    // Температура и точка росы
    if (part.match(/^M?\d{2}\/M?\d{2}$/)) {
      const temps = part.split('/');
      data.temperature = parseInt(temps[0].replace('M', '-'));
      data.dewpoint = parseInt(temps[1].replace('M', '-'));
    }

    // Давление
    if (part.match(/^Q\d{4}$/)) {
      data.pressure = parseInt(part.substring(1));
    }

    // Облачность
    if (part.match(/^(SKC|CLR|FEW|SCT|BKN|OVC)\d{3}$/)) {
      const coverage = part.substring(0, 3);
      const height = parseInt(part.substring(3)) * 100;
      data.clouds.push({ coverage, height });
    }

    // Погодные явления
    if (part.match(/^(\+|-|VC)?(MI|PR|BC|DR|BL|SH|TS|FZ)?(DZ|RA|SN|SG|IC|PL|GR|GS|UP)?(BR|FG|FU|VA|DU|SA|HZ|PY)?(PO|SQ|FC|SS)$/)) {
      data.weather.push(part);
    }
  }

  return data;
}

// Получение данных METAR (без изменений)
async function fetchMetarData(icao) {
  updateConnectionStatus('loading', 'Loading METAR...');

  try {
    const response = await fetch(`https://metar.vatsim.net/${icao.toUpperCase()}`);

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const metarText = await response.text();

    if (!metarText || metarText.includes('No METAR available')) {
      throw new Error('No METAR data available');
    }

    const parsedData = parseMetar(metarText.trim());
    if (parsedData) {
      updateConnectionStatus('connected', 'METAR loaded');
      return parsedData;
    } else {
      throw new Error('Failed to parse METAR');
    }

  } catch (error) {
    console.error('METAR fetch error:', error);
    updateConnectionStatus('error', 'METAR error');

    // Возвращаем демо-данные в случае ошибки
    return generateDemoData(icao);
  }
}

// Генерация демо-данных (без изменений)
function generateDemoData(icao) {
  return {
    raw: `${icao} 121853Z 19005KT 9999 FEW020 SCT080 12/08 Q1013 NOSIG=`,
    icao: icao,
    time: '121853Z',
    wind: { direction: 190, speed: 5, gust: 0, variable: false, calm: false },
    visibility: 9999,
    weather: [],
    clouds: [
      { coverage: 'FEW', height: 2000 },
      { coverage: 'SCT', height: 8000 }
    ],
    temperature: 12,
    dewpoint: 8,
    pressure: 1013
  };
}

// Обновление статуса подключения (без изменений)
function updateConnectionStatus(status, text) {
  const statusEl = document.getElementById('connectionStatus');
  if (!statusEl) return;

  statusEl.className = `connection-status ${status}`;
  statusEl.querySelector('span').textContent = text;
}

// Конвертация единиц давления (без изменений)
function convertPressure(hpa) {
  return {
    hpa: hpa,
    mmhg: Math.round(hpa * 0.750062 * 100) / 100,
    inhg: Math.round(hpa * 0.02953 * 100) / 100
  };
}

// Инициализация API только один раз (без изменений)
async function getAPI() {
  if (!globalAPI) {
    globalAPI = new OurAirportsAPI();
    await globalAPI.loadDatabase();
  }
  return globalAPI;
}
</script>

<!-- ========== КОНЕЦ ЧАСТИ 3 ==========><!-- ========== ЗАМЕНА ЧАСТИ 4A1-1: ФУНКЦИИ ОПРЕДЕЛЕНИЯ ЧАСОВЫХ ПОЯСОВ ========== -->

<script>
// ========== ОПРЕДЕЛЕНИЕ ЧАСОВОГО ПОЯСА ПО РЕГИОНАМ ИЗ CSV ==========

/**
 * Определение часового пояса по данным региона из CSV
 */
function getTimezoneByRegion(airport) {
  if (!airport) return 0;

  const country = airport.country || airport.iso_country || '';
  const region = airport.iso_region || '';
  const municipality = (airport.municipality || '').toLowerCase();
  const longitude = airport.longitude || 0;

  console.log(`🌍 Determining timezone for ${airport.icao}: country=${country}, region=${region}`);

  // ========== РОССИЯ - ПО РЕГИОНАМ ==========
  if (country === 'RU') {
    const regionTimezones = {
      // Калининградское время UTC+2
      'RU-KGD': 2,

      // Московское время UTC+3
      'RU-MOW': 3, 'RU-SPE': 3, 'RU-LEN': 3, 'RU-MOS': 3, 'RU-TUL': 3, 'RU-KLU': 3,
      'RU-BRY': 3, 'RU-SMO': 3, 'RU-TVE': 3, 'RU-YAR': 3, 'RU-VLA': 3, 'RU-IVA': 3,
      'RU-KOS': 3, 'RU-RYA': 3, 'RU-TAM': 3, 'RU-LIP': 3, 'RU-ORL': 3, 'RU-KRS': 3,
      'RU-BEL': 3, 'RU-VOR': 3, 'RU-NVG': 3, 'RU-PSK': 3, 'RU-MUR': 3, 'RU-ARK': 3,
      'RU-KRL': 3, 'RU-KDA': 3, 'RU-STA': 3, 'RU-ROS': 3, 'RU-AD': 3, 'RU-KL': 3,
      'RU-KC': 3, 'RU-KB': 3, 'RU-SE': 3, 'RU-IN': 3, 'RU-CE': 3, 'RU-DA': 3,

      // Самарское время UTC+4
      'RU-SAM': 4, 'RU-SAR': 4, 'RU-VGG': 4, 'RU-AST': 4, 'RU-ULY': 4, 'RU-PNZ': 4,
      'RU-NIZ': 4, 'RU-CHU': 4, 'RU-ME': 4, 'RU-MO': 4, 'RU-TA': 4, 'RU-KI': 4, 'RU-UD': 4,

      // Екатеринбургское время UTC+5
      'RU-SVE': 5, 'RU-CHE': 5, 'RU-KGN': 5, 'RU-TYU': 5, 'RU-PER': 5, 'RU-BA': 5,
      'RU-ORE': 5, 'RU-YAN': 5, 'RU-KHM': 5,

      // Омское время UTC+6
      'RU-OMS': 6, 'RU-NVS': 6, 'RU-TOM': 6, 'RU-KEM': 6, 'RU-AL': 6, 'RU-ALT': 6,

      // Красноярское время UTC+7
      'RU-KYA': 7, 'RU-KK': 7, 'RU-TY': 7,

      // Иркутское время UTC+8
      'RU-IRK': 8, 'RU-BU': 8,

      // Якутское время UTC+9
      'RU-ZAB': 9, 'RU-AMU': 9, 'RU-SA': 9,

      // Владивостокское время UTC+10
      'RU-PRI': 10, 'RU-KHA': 10, 'RU-YEV': 10,

      // Магаданское время UTC+11
      'RU-MAG': 11, 'RU-SAK': 11,

      // Камчатское время UTC+12
      'RU-KAM': 12, 'RU-CHU': 12,
    };

    const timezone = regionTimezones[region];
    if (timezone !== undefined) {
      console.log(`✅ Russian timezone for ${region}: UTC+${timezone}`);
      return timezone;
    }

    // Fallback по долготе для России
    if (longitude < 30) return 2;
    if (longitude < 45) return 3;
    if (longitude < 60) return 4;
    if (longitude < 75) return 5;
    if (longitude < 105) return 6;
    if (longitude < 120) return 7;
    if (longitude < 135) return 8;
    if (longitude < 150) return 9;
    if (longitude < 165) return 10;
    if (longitude < 175) return 11;
    return 12;
  }

  // ========== США - ПО ШТАТАМ ==========
  if (country === 'US') {
    const now = new Date();
    const isDST = isDaylightSavingTimeUS(now);

    const stateTimezones = {
      // Eastern Time
      'US-ME': isDST ? -4 : -5, 'US-NH': isDST ? -4 : -5, 'US-VT': isDST ? -4 : -5,
      'US-MA': isDST ? -4 : -5, 'US-RI': isDST ? -4 : -5, 'US-CT': isDST ? -4 : -5,
      'US-NY': isDST ? -4 : -5, 'US-NJ': isDST ? -4 : -5, 'US-PA': isDST ? -4 : -5,
      'US-DE': isDST ? -4 : -5, 'US-MD': isDST ? -4 : -5, 'US-DC': isDST ? -4 : -5,
      'US-VA': isDST ? -4 : -5, 'US-WV': isDST ? -4 : -5, 'US-NC': isDST ? -4 : -5,
      'US-SC': isDST ? -4 : -5, 'US-GA': isDST ? -4 : -5, 'US-FL': isDST ? -4 : -5,
      'US-OH': isDST ? -4 : -5, 'US-KY': isDST ? -4 : -5, 'US-TN': isDST ? -4 : -5,
      'US-MI': isDST ? -4 : -5,

      // Central Time
      'US-WI': isDST ? -5 : -6, 'US-IL': isDST ? -5 : -6, 'US-IN': isDST ? -5 : -6,
      'US-MN': isDST ? -5 : -6, 'US-IA': isDST ? -5 : -6, 'US-MO': isDST ? -5 : -6,
      'US-AR': isDST ? -5 : -6, 'US-LA': isDST ? -5 : -6, 'US-MS': isDST ? -5 : -6,
      'US-AL': isDST ? -5 : -6, 'US-ND': isDST ? -5 : -6, 'US-SD': isDST ? -5 : -6,
      'US-NE': isDST ? -5 : -6, 'US-KS': isDST ? -5 : -6, 'US-OK': isDST ? -5 : -6,
      'US-TX': isDST ? -5 : -6,

      // Mountain Time
      'US-MT': isDST ? -6 : -7, 'US-WY': isDST ? -6 : -7, 'US-CO': isDST ? -6 : -7,
      'US-NM': isDST ? -6 : -7, 'US-UT': isDST ? -6 : -7, 'US-ID': isDST ? -6 : -7,
      'US-AZ': -7, 'US-NV': isDST ? -7 : -8,

      // Pacific Time
      'US-WA': isDST ? -7 : -8, 'US-OR': isDST ? -7 : -8, 'US-CA': isDST ? -7 : -8,

      // Alaska и Hawaii
      'US-AK': isDST ? -8 : -9, 'US-HI': -10,
    };

    const timezone = stateTimezones[region];
    if (timezone !== undefined) {
      console.log(`✅ US timezone for ${region}: UTC${timezone >= 0 ? '+' : ''}${timezone} (DST: ${isDST})`);
      return timezone;
    }

    // Fallback по долготе для США
    if (longitude > -75) return isDST ? -4 : -5;
    if (longitude > -90) return isDST ? -5 : -6;
    if (longitude > -105) return isDST ? -6 : -7;
    if (longitude > -120) return isDST ? -7 : -8;
    return isDST ? -8 : -9;
  }

  // ========== ЕВРОПА - ПО СТРАНАМ ==========
  const europeanCountries = {
    'GB': 0, 'IE': 0, 'PT': 0, 'IS': 0,
    'FR': 1, 'ES': 1, 'DE': 1, 'IT': 1, 'AT': 1, 'CH': 1, 'NL': 1, 'BE': 1,
    'LU': 1, 'DK': 1, 'NO': 1, 'SE': 1, 'PL': 1, 'CZ': 1, 'SK': 1, 'HU': 1,
    'SI': 1, 'HR': 1, 'BA': 1, 'RS': 1, 'ME': 1, 'MK': 1, 'AL': 1,
    'FI': 2, 'EE': 2, 'LV': 2, 'LT': 2, 'UA': 2, 'MD': 2, 'RO': 2, 'BG': 2,
    'GR': 2, 'CY': 2, 'BY': 3, 'TR': 3
  };

  if (europeanCountries.hasOwnProperty(country)) {
    let baseOffset = europeanCountries[country];

    const noDSTCountries = ['IS', 'BY', 'TR'];
    if (!noDSTCountries.includes(country)) {
      const now = new Date();
      const isDST = isDaylightSavingTimeEU(now);
      if (isDST) baseOffset += 1;

      console.log(`✅ European timezone for ${country}: UTC+${baseOffset} (DST: ${isDST})`);
    } else {
      console.log(`✅ European timezone for ${country}: UTC+${baseOffset} (no DST)`);
    }

    return baseOffset;
  }

  // ========== ДРУГИЕ СТРАНЫ ==========
  const otherCountries = {
    'KZ': 6, 'KG': 6, 'TJ': 5, 'TM': 5, 'UZ': 5, 'AZ': 4, 'AM': 4, 'GE': 4,
    'CN': 8, 'JP': 9, 'KR': 9, 'IN': 5.5, 'AU': 10, 'NZ': 12, 'BR': -3,
    'AR': -3, 'MX': -6, 'EG': 2, 'ZA': 2, 'SA': 3, 'AE': 4, 'TH': 7, 'SG': 8
  };

  if (otherCountries.hasOwnProperty(country)) {
    let timezone = otherCountries[country];

    if (country === 'AU') {
      const isDST = isDaylightSavingTimeAU(new Date());
      if (isDST) timezone += 1;
    } else if (country === 'NZ') {
      const isDST = isDaylightSavingTimeNZ(new Date());
      if (isDST) timezone += 1;
    }

    console.log(`✅ Timezone for ${country}: UTC${timezone >= 0 ? '+' : ''}${timezone}`);
    return timezone;
  }

  // ========== FALLBACK - ПО ДОЛГОТЕ ==========
  console.log(`⚠️ Unknown country: ${country}, using longitude-based calculation`);
  let offset = Math.round(longitude / 15);
  return Math.max(-12, Math.min(14, offset));
}

/**
 * Получение часового пояса аэропорта из CSV данных
 */
function getAirportTimezoneFromCSV(icao) {
  if (!globalAPI || !globalAPI.airports) {
    console.warn('⚠️ Airport database not loaded');
    return 0;
  }

  const airport = globalAPI.airports.get(icao.toUpperCase());

  if (!airport) {
    console.warn(`⚠️ Airport ${icao} not found`);
    return 0;
  }

  const timezone = getTimezoneByRegion(airport);
  console.log(`🕐 Final timezone for ${icao}: UTC${timezone >= 0 ? '+' : ''}${timezone}`);

  return timezone;
}

// ========== ФУНКЦИИ DST ==========

function isDaylightSavingTimeUS(date) {
  const year = date.getFullYear();
  const month = date.getMonth();
  const day = date.getDate();

  if (month < 2 || month > 10) return false;
  if (month > 2 && month < 10) return true;

  if (month === 2) {
    const secondSunday = getSecondSunday(year, 3);
    return day >= secondSunday;
  }

  if (month === 10) {
    const firstSunday = getFirstSunday(year, 11);
    return day < firstSunday;
  }

  return false;
}

function isDaylightSavingTimeEU(date) {
  const year = date.getFullYear();
  const month = date.getMonth();
  const day = date.getDate();

  if (month < 2 || month > 9) return false;
  if (month > 2 && month < 9) return true;

  if (month === 2) {
    const lastSunday = getLastSunday(year, 3);
    return day >= lastSunday;
  }

  if (month === 9) {
    const lastSunday = getLastSunday(year, 10);
    return day < lastSunday;
  }

  return false;
}

function isDaylightSavingTimeAU(date) {
  const year = date.getFullYear();
  const month = date.getMonth();
  const day = date.getDate();

  if (month >= 4 && month <= 8) return false;
  if (month >= 10 || month <= 2) return true;

  if (month === 9) {
    const firstSunday = getFirstSunday(year, 10);
    return day >= firstSunday;
  }

  if (month === 3) {
    const firstSunday = getFirstSunday(year, 4);
    return day < firstSunday;
  }

  return false;
}

function isDaylightSavingTimeNZ(date) {
  const year = date.getFullYear();
  const month = date.getMonth();
  const day = date.getDate();

  if (month >= 1 && month <= 8) return false;
  if (month >= 10) return true;

  if (month === 9) {
    const firstSunday = getFirstSunday(year, 10);
    return day >= firstSunday;
  }

  if (month === 0) {
    const thirdSunday = getThirdSunday(year, 1);
    return day < thirdSunday;
  }

  return false;
}

// Вспомогательные функции для вычисления дат
function getSecondSunday(year, month) {
  const firstDay = new Date(year, month - 1, 1);
  const firstSunday = 7 - firstDay.getDay() + 1;
  return firstSunday > 7 ? firstSunday - 7 + 7 : firstSunday + 7;
}

function getFirstSunday(year, month) {
  const firstDay = new Date(year, month - 1, 1);
  return 7 - firstDay.getDay() + 1;
}

function getLastSunday(year, month) {
  const lastDay = new Date(year, month, 0);
  const lastDate = lastDay.getDate();
  const lastDayOfWeek = lastDay.getDay();
  return lastDate - lastDayOfWeek;
}

function getThirdSunday(year, month) {
  const firstDay = new Date(year, month - 1, 1);
  const firstSunday = 7 - firstDay.getDay() + 1;
  return (firstSunday > 7 ? firstSunday - 7 : firstSunday) + 14;
}

// Тестовая функция
window.testAirportTimezone = function(icao = 'UUEE') {
  console.log(`🧪 Testing regional timezone for ${icao}...`);

  if (!globalAPI || !globalAPI.loaded) {
    console.error('❌ Database not loaded');
    return 'Database not loaded';
  }

  const airport = globalAPI.getAirportInfo(icao);
  if (!airport) {
    console.error(`❌ Airport ${icao} not found`);
    return 'Airport not found';
  }

  console.log(`📊 Airport: ${airport.name}`);
  console.log(`   🌍 Country: ${airport.country}`);
  console.log(`   📍 Region: ${airport.iso_region}`);
  console.log(`   🏙️ City: ${airport.municipality}`);

  const timezone = getTimezoneByRegion(airport);
  console.log(`   ⏰ Timezone: UTC${timezone >= 0 ? '+' : ''}${timezone}`);

  return { airport, timezone };
};
</script>

<!-- ========== КОНЕЦ ЧАСТИ 4A1-1 ========== --> <!-- ========== ЗАМЕНА ЧАСТИ 4A1-2: ИСПРАВЛЕННЫЕ ФУНКЦИИ ВРЕМЕНИ И ВОСХОДА/ЗАХОДА ========== -->

<script>
// ========== ИСПРАВЛЕННЫЕ ФУНКЦИИ ВОСХОДА/ЗАХОДА И ВРЕМЕНИ ==========

/**
 * ИСПРАВЛЕННАЯ функция загрузки данных аэродрома
 */
async function updateSunriseSunset() {
  const currentIcao = document.getElementById('icaoInput').value;

  if (!currentIcao || currentIcao.length !== 4) {
    // Очищаем данные если ICAO не введен
    document.getElementById('sunrise').textContent = '-';
    document.getElementById('sunset').textContent = '-';
    window.airportData = null;
    console.log('🔄 Cleared airport data - no ICAO entered');
    return;
  }

  try {
    const api = await getAPI();
    const airport = api.getAirportInfo(currentIcao);

    if (airport && airport.latitude && airport.longitude) {
      console.log(`🌅 Loading data for ${currentIcao}:`);
      console.log(`   📍 Location: ${airport.latitude}, ${airport.longitude}`);

      // Вычисляем восход/заход солнца
      const sunTimes = calculateSunriseSunset(airport.latitude, airport.longitude);

      // Получаем часовой пояс из региональных данных
      const timezoneOffset = getAirportTimezoneFromCSV(currentIcao);

      console.log(`⏰ Timezone from region: UTC${timezoneOffset >= 0 ? '+' : ''}${timezoneOffset}`);

      // СОХРАНЯЕМ ДАННЫЕ АЭРОПОРТА
      window.airportData = {
        icao: currentIcao,
        latitude: airport.latitude,
        longitude: airport.longitude,
        name: airport.name,
        country: airport.country,
        iso_region: airport.iso_region,
        municipality: airport.municipality,
        sunriseUTC: sunTimes.sunrise,
        sunsetUTC: sunTimes.sunset,
        timezoneOffset: timezoneOffset,
        sunType: sunTimes.type || 'normal'
      };

      console.log('✅ Airport data saved:', window.airportData);

      // СРАЗУ ОБНОВЛЯЕМ ОТОБРАЖЕНИЕ
      updateTimeDisplay();

    } else {
      throw new Error(`Airport coordinates not found for ${currentIcao}`);
    }
  } catch (error) {
    console.error('❌ Error loading airport data:', error);
    document.getElementById('sunrise').textContent = '-';
    document.getElementById('sunset').textContent = '-';
    window.airportData = null;
  }
}

/**
 * ИСПРАВЛЕННАЯ функция отображения времени
 */
function updateTimeDisplay() {
  const timeLabel = document.getElementById('timeLabel');
  const timeElement = document.getElementById('currentTime');
  const sunriseElement = document.getElementById('sunrise');
  const sunsetElement = document.getElementById('sunset');
  const now = new Date();

  const isLocalMode = timeLabel && !timeLabel.textContent.includes('UTC');

  if (isLocalMode && window.airportData) {
    // МЕСТНОЕ ВРЕМЯ АЭРОПОРТА
    const offset = window.airportData.timezoneOffset;
    const localTime = new Date(now.getTime() + (offset * 3600000));
    const hours = localTime.getUTCHours().toString().padStart(2, '0');
    const minutes = localTime.getUTCMinutes().toString().padStart(2, '0');
    timeElement.textContent = `${hours}:${minutes}`;

    // Местное время восхода/захода
    if (window.airportData.sunriseUTC && window.airportData.sunriseUTC !== '-') {
      const localSunrise = convertUTCToLocal(window.airportData.sunriseUTC, offset);
      sunriseElement.textContent = localSunrise;
    }

    if (window.airportData.sunsetUTC && window.airportData.sunsetUTC !== '-') {
      const localSunset = convertUTCToLocal(window.airportData.sunsetUTC, offset);
      sunsetElement.textContent = localSunset;
    }

    console.log(`✅ LOCAL mode: ${hours}:${minutes} (${window.airportData.icao})`);

  } else if (isLocalMode && !window.airportData) {
    // СИСТЕМНОЕ МЕСТНОЕ ВРЕМЯ
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    timeElement.textContent = `${hours}:${minutes}`;

    console.log(`✅ LOCAL mode: system time ${hours}:${minutes}`);

  } else {
    // UTC ВРЕМЯ
    const hours = now.getUTCHours().toString().padStart(2, '0');
    const minutes = now.getUTCMinutes().toString().padStart(2, '0');
    timeElement.textContent = `${hours}:${minutes}`;

    // UTC время восхода/захода
    if (window.airportData) {
      sunriseElement.textContent = window.airportData.sunriseUTC || '-';
      sunsetElement.textContent = window.airportData.sunsetUTC || '-';
    }

    console.log(`✅ UTC mode: ${hours}:${minutes}`);
  }
}

/**
 * Конвертация UTC времени в местное время
 */
function convertUTCToLocal(utcTime, timezoneOffset) {
  if (!utcTime || utcTime === '-' || utcTime === '--:--') return utcTime;

  const [hours, minutes] = utcTime.split(':').map(Number);
  const utcDate = new Date();
  utcDate.setUTCHours(hours, minutes, 0, 0);
  const localDate = new Date(utcDate.getTime() + (timezoneOffset * 3600000));
  const localHours = localDate.getUTCHours().toString().padStart(2, '0');
  const localMinutes = localDate.getUTCMinutes().toString().padStart(2, '0');

  return `${localHours}:${localMinutes}`;
}

/**
 * ИСПРАВЛЕННАЯ функция переключения между UTC и местным временем
 */
function toggleTimeDisplay() {
  const timeLabel = document.getElementById('timeLabel');
  const sunriseLabel = document.getElementById('sunriseLabel');
  const sunsetLabel = document.getElementById('sunsetLabel');
  const lang = document.getElementById('language').value;

  if (!timeLabel) return;

  const isUTC = timeLabel.textContent.includes('UTC');

  if (isUTC) {
    // Переключаем UTC → Local
    if (lang === 'ru') {
      timeLabel.textContent = 'Время местное';
      if (sunriseLabel) sunriseLabel.textContent = 'Восход';
      if (sunsetLabel) sunsetLabel.textContent = 'Заход';
    } else {
      timeLabel.textContent = 'Local time';
      if (sunriseLabel) sunriseLabel.textContent = 'Sunrise';
      if (sunsetLabel) sunsetLabel.textContent = 'Sunset';
    }
    console.log('⏰ Switched to LOCAL time mode');
  } else {
    // Переключаем Local → UTC
    if (lang === 'ru') {
      timeLabel.textContent = 'Время UTC';
      if (sunriseLabel) sunriseLabel.textContent = 'Восход';
      if (sunsetLabel) sunsetLabel.textContent = 'Заход';
    } else {
      timeLabel.textContent = 'Time UTC';
      if (sunriseLabel) sunriseLabel.textContent = 'Sunrise';
      if (sunsetLabel) sunsetLabel.textContent = 'Sunset';
    }
    console.log('⏰ Switched to UTC time mode');
  }

  // СРАЗУ ОБНОВЛЯЕМ ОТОБРАЖЕНИЕ
  updateTimeDisplay();
}

/**
 * Подключение обработчиков клика для переключения времени
 */
function attachTimeClickHandlers() {
  const timeElement = document.getElementById('currentTime');
  const sunriseElement = document.getElementById('sunrise');
  const sunsetElement = document.getElementById('sunset');

  if (timeElement) {
    timeElement.style.cursor = 'pointer';
    timeElement.addEventListener('click', toggleTimeDisplay);
  }

  if (sunriseElement) {
    sunriseElement.style.cursor = 'pointer';
    sunriseElement.addEventListener('click', toggleTimeDisplay);
  }

  if (sunsetElement) {
    sunsetElement.style.cursor = 'pointer';
    sunsetElement.addEventListener('click', toggleTimeDisplay);
  }

  console.log('✅ Time click handlers attached');
}

// ========== ТОЧНОЕ ВЫЧИСЛЕНИЕ ВОСХОДА/ЗАХОДА ==========

function calculateSunriseSunset(latitude, longitude, date = new Date()) {
  try {
    if (Math.abs(latitude) > 90 || Math.abs(longitude) > 180) {
      return { sunrise: '-', sunset: '-' };
    }

    if (Math.abs(latitude) > 66.5) {
      const result = calculatePolarSunriseSunsetPrecise(latitude, longitude, date);
      if (result) return result;
    }

    const year = date.getUTCFullYear();
    const month = date.getUTCMonth() + 1;
    const day = date.getUTCDate();

    const julianDay = getJulianDay(year, month, day);
    const n = julianDay - 2451545.0;
    const T = n / 36525.0;

    const L0 = (280.46646 + T * (36000.76983 + T * 0.0003032)) % 360;
    const M = (357.52911 + T * (35999.05029 - 0.0001537 * T)) % 360;
    const Mrad = M * Math.PI / 180;

    const e = 0.016708634 - T * (0.000042037 + 0.0000001267 * T);

    const C = Math.sin(Mrad) * (1.914602 - T * (0.004817 + 0.000014 * T)) +
              Math.sin(2 * Mrad) * (0.019993 - 0.000101 * T) +
              Math.sin(3 * Mrad) * 0.000289;

    const theta = L0 + C;
    const omega = 125.04 - 1934.136 * T;
    const lambda = theta - 0.00569 - 0.00478 * Math.sin(omega * Math.PI / 180);
    const lambdaRad = lambda * Math.PI / 180;

    const epsilon0 = 23 + (26 + ((21.448 - T * (46.8150 + T * (0.00059 - T * 0.001813)))) / 60) / 60;
    const epsilon = epsilon0 + 0.00256 * Math.cos(omega * Math.PI / 180);
    const epsilonRad = epsilon * Math.PI / 180;

    const delta = Math.asin(Math.sin(epsilonRad) * Math.sin(lambdaRad));

    const y = Math.tan(epsilonRad / 2) * Math.tan(epsilonRad / 2);
    const E = 4 * (y * Math.sin(2 * L0 * Math.PI / 180) - 2 * e * Math.sin(Mrad) +
                   4 * e * y * Math.sin(Mrad) * Math.cos(2 * L0 * Math.PI / 180) -
                   0.5 * y * y * Math.sin(4 * L0 * Math.PI / 180) -
                   1.25 * e * e * Math.sin(2 * Mrad)) * 180 / Math.PI;

    const latRad = latitude * Math.PI / 180;
    const h0 = -0.8333;
    const cosH = (Math.sin(h0 * Math.PI / 180) - Math.sin(latRad) * Math.sin(delta)) /
                 (Math.cos(latRad) * Math.cos(delta));

    if (cosH > 1) {
      return { sunrise: '--:--', sunset: '--:--', type: 'polar_night' };
    }
    if (cosH < -1) {
      return { sunrise: '--:--', sunset: '--:--', type: 'polar_day' };
    }

    const H = Math.acos(cosH) * 180 / Math.PI;

    const sunriseUTC = 12 - H/15 - longitude/15 - E/60;
    const sunsetUTC = 12 + H/15 - longitude/15 - E/60;

    const sunrise = normalizeTime(sunriseUTC);
    const sunset = normalizeTime(sunsetUTC);

    return { sunrise, sunset, type: 'precise' };

  } catch (error) {
    console.error('Error calculating sunrise/sunset:', error);
    return { sunrise: '-', sunset: '-', type: 'error' };
  }
}

function getJulianDay(year, month, day) {
  if (month <= 2) {
    year -= 1;
    month += 12;
  }

  const A = Math.floor(year / 100);
  const B = 2 - A + Math.floor(A / 4);

  return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + B - 1524.5;
}

function normalizeTime(timeDecimal) {
  let hours = timeDecimal;
  while (hours < 0) hours += 24;
  while (hours >= 24) hours -= 24;

  const h = Math.floor(hours);
  const m = Math.round((hours - h) * 60);

  if (m >= 60) {
    return normalizeTime(h + 1);
  }

  return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
}

function calculatePolarSunriseSunsetPrecise(latitude, longitude, date) {
  const julianDay = getJulianDay(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate());
  const n = julianDay - 2451545.0;

  const P = Math.asin(0.39795 * Math.cos(0.98563 * (n - 173) * Math.PI / 180));
  const criticalAngle = Math.PI/2 - Math.abs(latitude * Math.PI / 180);

  if (latitude > 0) {
    if (P > criticalAngle) {
      return { sunrise: '00:00', sunset: '23:59', type: 'polar_day' };
    }
    if (P < -criticalAngle) {
      return { sunrise: '--:--', sunset: '--:--', type: 'polar_night' };
    }
  } else {
    if (P < -criticalAngle) {
      return { sunrise: '00:00', sunset: '23:59', type: 'polar_day' };
    }
    if (P > criticalAngle) {
      return { sunrise: '--:--', sunset: '--:--', type: 'polar_night' };
    }
  }

  return null;
}
</script>

<!-- ========== КОНЕЦ ЧАСТИ 4A1-2 ========== --><!-- ========== БЛОК 4A2 ПОЛНЫЙ ИСПРАВЛЕННЫЙ: QFE КАК QNH ========== -->

<script>
// ========== ИСПРАВЛЕННАЯ ФУНКЦИЯ ОБНОВЛЕНИЯ СПИСКА ВПП ==========
async function updateRunwayOptions(icao) {
    const select = document.getElementById('runwaySelect');

    // Показываем состояние загрузки
    select.innerHTML = '<option value="">Loading runways...</option>';
    select.disabled = true;

    try {
        console.log(`🛬 Loading runway data for ${icao}...`);

        // Используем глобальный API объект
        const api = await getAPI();
        currentRunwayData = await api.getRunwayData(icao);

        if (!currentRunwayData || currentRunwayData.length === 0) {
            throw new Error(`No runways found for ${icao}`);
        }

        // Формируем список ВПП
        const runwayList = [];
        currentRunwayData.forEach((runway) => {
            if (runway.leIdent && runway.leIdent !== '-' && runway.leIdent.trim() !== '') {
                runwayList.push(runway.leIdent.trim());
            }
            if (runway.heIdent && runway.heIdent !== '-' && runway.heIdent.trim() !== '') {
                runwayList.push(runway.heIdent.trim());
            }
        });

        // Убираем дубликаты и сортируем
        const uniqueRunways = [...new Set(runwayList)].sort();

        if (uniqueRunways.length === 0) {
            throw new Error(`No valid runway identifiers found for ${icao}`);
        }

        // Обновляем селектор с реальными данными
        select.innerHTML = '';
        uniqueRunways.forEach(runway => {
            const option = new Option(runway, runway);
            select.appendChild(option);
        });

        // Выбираем первую ВПП по умолчанию
        select.value = uniqueRunways[0];
        select.disabled = false;

        // Обновляем противоположную ВПП
        updateOppositeRunway();

        // Обновляем компасы ТОЛЬКО если есть METAR данные
        if (currentMetarData) {
            initializeCompass('compass');
            initializeCompass('compass2');
            updateWindComponents();
        } else {
            initializeCompassWithRunway('compass');
            initializeCompassWithRunway('compass2');
        }

        // ИСПРАВЛЕНО: Обновляем QFE с правильным расчетом
        updateQFEForSelectedRunways();

        updateConnectionStatus('connected', `${uniqueRunways.length} runways loaded`);
        console.log(`✅ Successfully loaded ${uniqueRunways.length} runways for ${icao}:`, uniqueRunways);

    } catch (error) {
        console.error(`❌ Failed to load runway data for ${icao}:`, error);

        select.innerHTML = '<option value="">No runway data</option>';
        select.disabled = true;

        document.getElementById('runwayDisplay2').textContent = '--';
        currentRunwayData = null;

        initializeEmptyCompass('compass');
        initializeEmptyCompass('compass2');

        document.querySelectorAll('.lateral-component .data-value').forEach(el => el.textContent = '-');
        document.querySelectorAll('.headwind-component .data-value').forEach(el => el.textContent = '-');
        document.querySelectorAll('.friction-coefficient .data-value').forEach(el => el.textContent = '-');

        document.querySelectorAll('.qfe-row, .elev-row').forEach(row => row.remove());

        updateConnectionStatus('error', `No runway data for ${icao}`);
    }
}

// ========== ИСПРАВЛЕННАЯ ФУНКЦИЯ ОБНОВЛЕНИЯ QFE ДЛЯ ВЫБРАННЫХ ВПП ==========
async function updateQFEForSelectedRunways() {
    if (!currentMetarData || !currentRunwayData) {
        console.log('⚠️ Cannot update QFE: missing METAR or runway data');
        return;
    }

    try {
        const api = await getAPI();
        const selectedRunway1 = document.getElementById('runwaySelect').value;
        const selectedRunway2 = document.getElementById('runwayDisplay2').textContent;

        console.log(`🔧 Updating QFE for runways: ${selectedRunway1} and ${selectedRunway2}`);

        if (selectedRunway1) {
            const elevation1 = api.getRunwayElevation(currentRunwayData, selectedRunway1);
            const qfe1 = api.calculateQFE(currentMetarData.pressure, elevation1);
            console.log(`✈️ Runway ${selectedRunway1}: elevation=${elevation1}m, QFE=${qfe1} hPa`);
            updateQFEDisplay('qfe1', qfe1, elevation1, 0);
        }

        if (selectedRunway2 && selectedRunway2 !== '--') {
            const elevation2 = api.getRunwayElevation(currentRunwayData, selectedRunway2);
            const qfe2 = api.calculateQFE(currentMetarData.pressure, elevation2);
            console.log(`✈️ Runway ${selectedRunway2}: elevation=${elevation2}m, QFE=${qfe2} hPa`);
            updateQFEDisplay('qfe2', qfe2, elevation2, 1);
        }
    } catch (error) {
        console.error('❌ Error updating QFE:', error);
    }
}

// ========== ПРАВИЛЬНОЕ ОТОБРАЖЕНИЕ QFE ТОЧНО КАК QNH ==========
function updateQFEDisplay(qfeId, qfeValue, elevation, compassIndex) {
    const compassInfo = document.querySelectorAll('.compass-info')[compassIndex];
    if (!compassInfo) {
        console.log(`⚠️ Cannot find compass-info for index ${compassIndex}`);
        return;
    }

    console.log(`🔧 Updating QFE display exactly like QNH for compass ${compassIndex + 1}: QFE=${qfeValue}, elevation=${elevation}m`);

    // Удаляем старые QFE поля чтобы избежать дублирования
    const existingQFE = compassInfo.querySelectorAll('.qfe-row, .elev-row');
    existingQFE.forEach(row => row.remove());

    if (qfeValue !== null && qfeValue !== undefined && !isNaN(qfeValue)) {
        // Конвертируем QFE в разные единицы
        const qfePressure = convertPressure(qfeValue);
        console.log(`💱 QFE pressure conversion:`, qfePressure);

        // ИСПРАВЛЕНО: Создаем QFE блок ТОЧНО КАК QNH В ЦЕНТРЕ
        const qfeRow = document.createElement('div');
        qfeRow.className = 'qfe-row';

        // ИСПРАВЛЕНО: Простая структура QFE как QNH
        qfeRow.innerHTML = `
            <div class="qfe-label">QFE</div>
            <div class="qfe-fields">
                <div class="qfe-field primary">
                    <div class="data-field">
                        <div class="data-value">${qfePressure.hpa || '-'}</div>
                    </div>
                    <div class="units">hPa</div>
                </div>
                <div class="qfe-field secondary">
                    <div class="data-field">
                        <div class="data-value">${qfePressure.mmhg || '-'}</div>
                    </div>
                    <div class="units">mmHg</div>
                </div>
                <div class="qfe-field secondary">
                    <div class="data-field">
                        <div class="data-value">${qfePressure.inhg || '-'}</div>
                    </div>
                    <div class="units">inHg</div>
                </div>
            </div>
        `;
        compassInfo.appendChild(qfeRow);

        // Добавляем информацию о высоте ELEVATION в отдельный блок слева внизу
        const elevRow = document.createElement('div');
        elevRow.className = 'elev-row';
        elevRow.innerHTML = `
            <div class="section-label">ELEV</div>
            <div class="data-field">
                <div class="data-value">${elevation ? Math.round(elevation) : '-'}</div>
            </div>
            <div class="units">м</div>
        `;
        compassInfo.appendChild(elevRow);

        console.log(`✅ QFE display updated exactly like QNH for compass ${compassIndex + 1}: ${qfeValue} hPa, elevation: ${elevation}m`);
    } else {
        console.log(`⚠️ Invalid QFE value for compass ${compassIndex + 1}: ${qfeValue}`);
    }
}

// ========== ИСПРАВЛЕННАЯ ФУНКЦИЯ ОБНОВЛЕНИЯ ПРОТИВОПОЛОЖНОЙ ВПП ==========
function updateOppositeRunway() {
    const sel = document.getElementById('runwaySelect').value;
    const opp = getOppositeRunway(sel);
    document.getElementById('runwayDisplay2').textContent = opp;

    console.log(`🔄 Updated opposite runway: ${sel} → ${opp}`);

    // Обновляем компасы
    if (currentMetarData) {
        initializeCompass('compass');
        initializeCompass('compass2');
        updateWindComponents();
    } else {
        initializeCompassWithRunway('compass');
        initializeCompassWithRunway('compass2');
    }

    // ИСПРАВЛЕНО: Обновляем QFE после изменения ВПП
    updateQFEForSelectedRunways();
}

// ========== ПОЛУЧЕНИЕ ПРОТИВОПОЛОЖНОЙ ВПП ==========
function getOppositeRunway(selectedRunway) {
    if (!currentRunwayData) return '--';

    for (const runway of currentRunwayData) {
        if (runway.leIdent === selectedRunway) {
            return runway.heIdent;
        }
        if (runway.heIdent === selectedRunway) {
            return runway.leIdent;
        }
    }
    return '--';
}

// ========== РАСЧЕТ КОМПОНЕНТОВ ВЕТРА ==========
function calculateWindComponents(windDir, windSpeed, runwayHeading) {
    const windAngleRad = (windDir - runwayHeading) * Math.PI / 180;

    const headwind = Math.round(windSpeed * Math.cos(windAngleRad) * 10) / 10;
    const crosswind = Math.round(windSpeed * Math.sin(windAngleRad) * 10) / 10;

    return { headwind, crosswind };
}

// ========== ОБНОВЛЕНИЕ КОМПОНЕНТОВ ВЕТРА ==========
function updateWindComponents() {
    if (!currentMetarData || !currentRunwayData) return;

    const windDir = currentMetarData.wind.calm ? 0 : currentMetarData.wind.direction;
    const windSpeed = currentMetarData.wind.calm ? 0 : currentMetarData.wind.speed;

    // Для первого компаса
    const selectedRunway1 = document.getElementById('runwaySelect').value;
    if (selectedRunway1) {
        const runwayHeading = getRunwayHeading(selectedRunway1);
        const components1 = calculateWindComponents(windDir, windSpeed, runwayHeading);

        const lateral1 = document.querySelector('#compass').parentElement.querySelector('.lateral-component .data-value');
        const headwind1 = document.querySelector('#compass').parentElement.querySelector('.headwind-component .data-value');

        if (lateral1) lateral1.textContent = components1.crosswind > 0 ? `+${components1.crosswind.toFixed(1)}` : components1.crosswind.toFixed(1);
        if (headwind1) headwind1.textContent = components1.headwind > 0 ? `+${components1.headwind.toFixed(1)}` : components1.headwind.toFixed(1);
    }

    // Для второго компаса
    const selectedRunway2 = document.getElementById('runwayDisplay2').textContent;
    if (selectedRunway2 && selectedRunway2 !== '--') {
        const runwayHeading = getRunwayHeading(selectedRunway2);
        const components2 = calculateWindComponents(windDir, windSpeed, runwayHeading);

        const lateral2 = document.querySelector('#compass2').parentElement.querySelector('.lateral-component .data-value');
        const headwind2 = document.querySelector('#compass2').parentElement.querySelector('.headwind-component .data-value');

        if (lateral2) lateral2.textContent = components2.crosswind > 0 ? `+${components2.crosswind.toFixed(1)}` : components2.crosswind.toFixed(1);
        if (headwind2) headwind2.textContent = components2.headwind > 0 ? `+${components2.headwind.toFixed(1)}` : components2.headwind.toFixed(1);
    }
}

// ========== ПОЛУЧЕНИЕ КУРСА ВПП ==========
function getRunwayHeading(runwayIdent) {
    if (!currentRunwayData) return 0;

    for (const runway of currentRunwayData) {
        if (runway.leIdent === runwayIdent) return runway.leHeading;
        if (runway.heIdent === runwayIdent) return runway.heHeading;
    }

    // Если не найдено в данных, вычисляем из номера ВПП
    const runwayNumber = parseInt(runwayIdent.replace(/[LRC]/g, ''));
    return runwayNumber * 10;
}

// Обновление UI с данными METAR - ИСПРАВЛЕННАЯ ВЕРСИЯ
function updateWeatherDisplay(data) {
    if (!data) return;

    console.log('🌦️ Updating weather display with METAR data:', data);

    // Обновляем код METAR
    document.getElementById('metarCode').textContent = data.raw;

    // ИСПРАВЛЯЕМ ОТОБРАЖЕНИЕ ДАВЛЕНИЯ QNH - ИСПОЛЬЗУЕМ ПРЯМЫЕ ID
    if (data.pressure && data.pressure > 0) {
        const pressure = convertPressure(data.pressure);

        console.log('🔧 Updating pressure fields:', pressure);

        // Ищем поля QNH по структуре HTML - находим элементы с правильными units
        const allWeatherRows = document.querySelectorAll('.weather-row');
        console.log(`🔍 Found ${allWeatherRows.length} weather rows`);

        let hpaField = null, mmhgField = null, inhgField = null;
        let tempField = null, dewField = null;

        allWeatherRows.forEach((row, index) => {
            const label = row.querySelector('.section-label');
            const value = row.querySelector('.data-value');
            const units = row.querySelector('.units');

            if (!value || !units) return;

            const labelText = label ? label.textContent.trim() : '';
            const unitsText = units.textContent.trim();

            console.log(`Row ${index}: label="${labelText}", units="${unitsText}"`);

            // Определяем поля по единицам измерения
            if (unitsText === 'hPa' && !hpaField) {
                hpaField = value;
                console.log(`✅ Found QNH hPa field at row ${index}`);
            } else if (unitsText === 'mmHg' && !mmhgField) {
                mmhgField = value;
                console.log(`✅ Found QNH mmHg field at row ${index}`);
            } else if (unitsText === 'inHg' && !inhgField) {
                inhgField = value;
                console.log(`✅ Found QNH inHg field at row ${index}`);
            } else if (unitsText === '°C' && labelText === 'T' && !tempField) {
                tempField = value;
                console.log(`✅ Found Temperature field at row ${index}`);
            } else if (unitsText === '°C' && labelText === 'DP' && !dewField) {
                dewField = value;
                console.log(`✅ Found Dewpoint field at row ${index}`);
            }
        });

        // Обновляем поля давления
        if (hpaField) {
            hpaField.textContent = pressure.hpa;
            console.log(`✅ Set QNH hPa: ${pressure.hpa}`);
        } else {
            console.warn('❌ QNH hPa field not found');
        }

        if (mmhgField) {
            mmhgField.textContent = pressure.mmhg;
            console.log(`✅ Set QNH mmHg: ${pressure.mmhg}`);
        } else {
            console.warn('❌ QNH mmHg field not found');
        }

        if (inhgField) {
            inhgField.textContent = pressure.inhg;
            console.log(`✅ Set QNH inHg: ${pressure.inhg}`);
        } else {
            console.warn('❌ QNH inHg field not found');
        }

        // Обновляем температуру и точку росы
        if (tempField) {
            tempField.textContent = data.temperature !== null ? data.temperature : '-';
            console.log(`🌡️ Set temperature: ${data.temperature}°C`);
        } else {
            console.warn('❌ Temperature field not found');
        }

        if (dewField) {
            dewField.textContent = data.dewpoint !== null ? data.dewpoint : '-';
            console.log(`🌡️ Set dewpoint: ${data.dewpoint}°C`);
        } else {
            console.warn('❌ Dewpoint field not found');
        }

    } else {
        console.warn('❌ No valid pressure data in METAR');
        // Показываем прочерки для всех полей давления
        document.querySelectorAll('.weather-row').forEach(row => {
            const units = row.querySelector('.units');
            const value = row.querySelector('.data-value');
            if (units && value && ['hPa', 'mmHg', 'inHg'].includes(units.textContent.trim())) {
                value.textContent = '-';
            }
        });
    }

    // Видимость MOR
    const visEl = document.querySelector('#morLabel').parentElement.querySelector('.data-value');
    if (visEl) {
        visEl.textContent = data.visibility || '-';
        console.log(`👁️ Set visibility: ${data.visibility}m`);
    }

    // Ветер - обновляем отображение
    const windDir = data.wind.calm ? 0 : data.wind.direction;
    const windSpeed = data.wind.calm ? 0 : data.wind.speed;

    document.querySelectorAll('.wind-direction').forEach(el => {
        el.textContent = data.wind.calm ? '---°' : `${windDir.toString().padStart(3, '0')}°`;
    });

    document.querySelectorAll('.wind-speed').forEach(el => {
        // Показываем скорость ветра (пока без стрелок трендов)
        el.textContent = windSpeed.toString();
    });

    console.log(`💨 Set wind: ${windDir}°/${windSpeed}kt`);

    // ========== НОВОЕ: УЛУЧШЕННОЕ ДЕКОДИРОВАНИЕ ОБЛАЧНОСТИ С ПРЕДЛОГАМИ ==========
    const currentLanguage = document.getElementById('language').value === 'ru' ? 'ru' : 'en';

    // Декодируем облачность с помощью нового декодировщика
    const decodedClouds = decodeCloudiness(data.clouds, currentLanguage);
    console.log('☁️ Decoded clouds with prepositions:', decodedClouds);

    // Обновляем отображение облачности С ПРЕДЛОГАМИ И HTML ПЕРЕНОСАМИ
    const skyEl = document.querySelector('#skyConditionLabel').parentElement.querySelector('.data-value');
    if (skyEl) {
        skyEl.innerHTML = decodedClouds.summary; // ИЗМЕНЕНО: используем innerHTML для <br>
        console.log(`☁️ Sky condition with prepositions and line breaks: ${decodedClouds.summary}`);
    }

    // ========== ИСПРАВЛЕННОЕ ОТОБРАЖЕНИЕ ВНГО (САМАЯ НИЖНЯЯ ОБЛАЧНОСТЬ) В ФУТАХ ==========
    const cloudBaseEl = document.querySelector('#qbbLabel').parentElement.querySelector('.data-value');
    const cloudBaseUnitsEl = document.querySelector('#qbbLabel').parentElement.querySelector('.units');
    if (cloudBaseEl && cloudBaseUnitsEl) {
        let cloudBaseText = '-';

        // Ищем САМЫЙ НИЗКИЙ слой облаков (любой тип) для ВНГО
        const lowestCloudLayer = decodedClouds.layers
            .filter(layer => layer.height && layer.height > 0 && ['BKN', 'OVC', 'SCT', 'FEW'].includes(layer.coverageCode))
            .sort((a, b) => a.height - b.height)[0];

        if (lowestCloudLayer) {
            cloudBaseText = lowestCloudLayer.height.toString();
            console.log(`☁️ Lowest cloud base (ВНГО): ${cloudBaseText} feet`);
        } else if (decodedClouds.layers.length > 0) {
            // Если есть облачность но нет измеримой высоты (например SKC, CLR)
            const specialLayer = decodedClouds.layers.find(layer => layer.special);
            if (specialLayer && ['SKC', 'CLR', 'NSC', 'NCD'].some(code => specialLayer.code.includes(code))) {
                cloudBaseText = currentLanguage === 'ru' ? 'Ясно' : 'Clear';
                console.log(`☁️ Clear skies (ВНГО): ${cloudBaseText}`);
            } else if (specialLayer && specialLayer.code.includes('VV')) {
                // Для вертикальной видимости показываем высоту
                cloudBaseText = specialLayer.height ? specialLayer.height.toString() : 'VV';
                console.log(`☁️ Vertical visibility (ВНГО): ${cloudBaseText}`);
            }
        }

        cloudBaseEl.textContent = cloudBaseText;

        // ИСПРАВЛЕНО: Устанавливаем единицы для ВНГО в футах
        cloudBaseUnitsEl.textContent = currentLanguage === 'ru' ? 'фт' : 'ft';
    }

    // ========== НОВОЕ: ИЗВЛЕЧЕНИЕ QBB ИЗ РЕМАРОК ==========
    const qbbFromRemarks = extractQBBFromRemarks(data.raw, currentLanguage);
    if (qbbFromRemarks !== null) {
        // Если найден QBB в ремарках, заменяем ВНГО на QBB
        if (cloudBaseEl && cloudBaseUnitsEl) {
            cloudBaseEl.textContent = qbbFromRemarks.toString();
            cloudBaseUnitsEl.textContent = currentLanguage === 'ru' ? 'м' : 'm'; // QBB всегда в метрах
            console.log(`☁️ QBB from remarks: ${qbbFromRemarks} meters (overrides ВНГО)`);
        }
    }

    // ДЕКОДИРОВАНИЕ ПОГОДНЫХ ЯВЛЕНИЙ
    const weatherEl = document.getElementById('weatherPhenomena');
    if (weatherEl) {
        if (data.weather && data.weather.length > 0) {
            const decodedWeather = data.weather.map(weatherCode => {
                let decoded;
                if (weatherHybridDictionary[weatherCode]) {
                    decoded = weatherHybridDictionary[weatherCode][currentLanguage];
                } else {
                    decoded = decodeWeatherComponentAnalysis(weatherCode, currentLanguage);
                    decoded = decoded || weatherCode;
                }
                return decoded;
            });

            const finalWeatherText = formatWeatherList(decodedWeather);
            weatherEl.textContent = finalWeatherText;

        } else {
            weatherEl.textContent = '-';
        }
    }

    // Остальные обновления
    updateSunriseSunset();
    if (currentRunwayData) {
        initializeCompass('compass');
        initializeCompass('compass2');
        updateWindComponents();
    }
    updateQFEForSelectedRunways();

    console.log('✅ Weather display updated with cloud decoding and prepositions');
}

// УЛУЧШЕННАЯ ФУНКЦИЯ КОНВЕРТАЦИИ ДАВЛЕНИЯ
function convertPressure(hpa) {
    if (!hpa || hpa <= 0) {
        return { hpa: '-', mmhg: '-', inhg: '-' };
    }

    const result = {
        hpa: Math.round(hpa), // Целое число
        mmhg: Math.round(hpa * 0.750062), // ИСПРАВЛЕНО: Целое число без десятичных
        inhg: (hpa * 0.02953).toFixed(2) // Два знака после запятой
    };

    console.log(`🔧 Pressure conversion: ${hpa} hPa = ${result.mmhg} mmHg = ${result.inhg} inHg`);

    return result;
}

console.log('✅ Complete QFE functions updated with QNH-like layout - full block');
</script>

<style>
/* ========== QFE СТИЛИ ПРОСТЫЕ И РАБОЧИЕ ========== */

/* QFE блок - занимает правую колонку как в исходном коде */
.qfe-row {
    grid-column: 2;
    grid-row: 1 / span 2;
    display: flex;
    align-items: center;
    gap: min(6px,.6vw);
}

/* Заголовок QFE слева */
.qfe-row .qfe-label {
    color: #666;
    font-size: clamp(12px,1.2vw,16px);
    text-align: left;
}

/* Блок с полями QFE */
.qfe-row .qfe-fields {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1px;
}

/* Каждое поле QFE */
.qfe-row .qfe-field {
    display: flex;
    align-items: center;
    gap: min(4px,.4vw);
    width: 100%;
}

/* Блоки данных QFE - фиксированная ширина, выровнены по левому краю */
.qfe-row .qfe-field .data-field {
    width: 65px; /* Фиксированная ширина */
    min-width: 65px;
    max-width: 65px;
    text-align: center;
    padding: min(2px,.2vw);
    background: #f8f8f8;
    border-radius: 3px;
    flex-shrink: 0; /* Не сжимается */
}

/* Единицы QFE */
.qfe-row .qfe-field .units {
    color: #666;
    font-size: clamp(10px,1.0vw,13px);
    text-align: left;
}

/* Основное поле hPa */
.qfe-row .qfe-field.primary .data-value {
    font-size: clamp(11px,1.1vw,14px);
    font-weight: bold;
}

.qfe-row .qfe-field.primary .units {
    font-size: clamp(12px,1.2vw,16px);
}

/* Вторичные поля */
.qfe-row .qfe-field.secondary .data-value {
    font-size: clamp(11px,1.1vw,14px);
    font-weight: normal;
}

/* Темная тема */
.dark .qfe-row .qfe-label,
.dark .qfe-row .qfe-field .units {
    color: #ccc;
}

.dark .qfe-row .qfe-field .data-field {
    background: #333;
}

/* АДАПТИВНОСТЬ QFE */
@media (max-width: 900px) {
    .qfe-row .qfe-field .data-field {
        width: max(55px,5.5vw);
        padding: min(2px,.2vw);
    }
}

@media (max-width: 600px) {
    .qfe-row .qfe-header-row,
    .qfe-row .qfe-field.secondary {
        gap: min(2px,.2vw);
    }

    .qfe-row .qfe-field .data-field {
        width: max(50px,5vw);
    }
}
</style>

<!-- ========== КОНЕЦ БЛОКА 4A2 ПОЛНЫЙ ИСПРАВЛЕННЫЙ ==========><!-- ========== ЗАМЕНА ЧАСТИ 4B: ФИНАЛЬНАЯ ЧАСТЬ - КОМПАСЫ И ОБРАБОТЧИКИ ========== -->

<script>
// Инициализация компаса с ВПП (но без ветра)
function initializeCompassWithRunway(id) {
  const c = document.getElementById(id);
  c.innerHTML = '';
  const r = c.getBoundingClientRect();
  const s = Math.min(r.width, r.height);
  const rad = s / 2;
  const cx = s / 2, cy = s / 2;

  for (let i = 0; i < 36; i++) {
    const a = i * 10;
    const radian = (a - 90) * Math.PI / 180;
    const m = document.createElement('div');
    const maj = i % 3 === 0;
    m.className = maj ? 'compass-mark major' : 'compass-mark minor';
    const ml = maj ? 18 : 12, mw = maj ? 2 : 1;
    const or = rad - 1;
    const ox = cx + Math.cos(radian) * or, oy = cy + Math.sin(radian) * or;
    const ix = cx + Math.cos(radian) * (or - ml), iy = cy + Math.sin(radian) * (or - ml);
    const mcx = (ox + ix) / 2, mcy = (oy + iy) / 2;
    m.style.left = (mcx - mw / 2) + 'px';
    m.style.top = (mcy - ml / 2) + 'px';
    m.style.width = mw + 'px';
    m.style.height = ml + 'px';
    m.style.transform = `rotate(${a}deg)`;
    m.style.transformOrigin = 'center';
    c.appendChild(m);

    if (a % 30 === 0) {
      const n = document.createElement('div');
      n.className = 'compass-number';
      let d;
      if (a === 0) d = '36';
      else if (a === 30) d = '03';
      else if (a === 60) d = '06';
      else if (a === 90) d = '09';
      else if (a === 120) d = '12';
      else if (a === 150) d = '15';
      else if (a === 180) d = '18';
      else if (a === 210) d = '21';
      else if (a === 240) d = '24';
      else if (a === 270) d = '27';
      else if (a === 300) d = '30';
      else if (a === 330) d = '33';
      n.textContent = d;
      const nr = rad + 15;
      const nx = cx + Math.cos(radian) * nr, ny = cy + Math.sin(radian) * nr;
      n.style.left = (nx - 12) + 'px';
      n.style.top = (ny - 8) + 'px';
      c.appendChild(n);
    }
  }

  if (currentRunwayData) {
    const rw = document.createElement('div');
    rw.className = 'runway-display';
    let runwayAngle;

    if (id === 'compass') {
      rw.classList.add('left-landing');
      const sel = document.getElementById('runwaySelect') ? document.getElementById('runwaySelect').value : '';
      if (sel) {
        runwayAngle = getRunwayHeading(sel) - 90;
      } else {
        runwayAngle = 0;
      }
    } else {
      rw.classList.add('left-landing');
      const opp = document.getElementById('runwayDisplay2') ? document.getElementById('runwayDisplay2').textContent : '';
      if (opp && opp !== '--') {
        runwayAngle = getRunwayHeading(opp) - 90;
      } else {
        runwayAngle = 0;
      }
    }

    rw.style.transform = `translate(-50%,-50%) rotate(${runwayAngle}deg)`;
    c.appendChild(rw);
  }
}

// Инициализация полного компаса (с ВПП и ветром)
function initializeCompass(id) {
  const c = document.getElementById(id);
  c.innerHTML = '';
  const r = c.getBoundingClientRect();
  const s = Math.min(r.width, r.height);
  const rad = s / 2;
  const cx = s / 2, cy = s / 2;

  for (let i = 0; i < 36; i++) {
    const a = i * 10;
    const radian = (a - 90) * Math.PI / 180;
    const m = document.createElement('div');
    const maj = i % 3 === 0;
    m.className = maj ? 'compass-mark major' : 'compass-mark minor';
    const ml = maj ? 18 : 12, mw = maj ? 2 : 1;
    const or = rad - 1;
    const ox = cx + Math.cos(radian) * or, oy = cy + Math.sin(radian) * or;
    const ix = cx + Math.cos(radian) * (or - ml), iy = cy + Math.sin(radian) * (or - ml);
    const mcx = (ox + ix) / 2, mcy = (oy + iy) / 2;
    m.style.left = (mcx - mw / 2) + 'px';
    m.style.top = (mcy - ml / 2) + 'px';
    m.style.width = mw + 'px';
    m.style.height = ml + 'px';
    m.style.transform = `rotate(${a}deg)`;
    m.style.transformOrigin = 'center';
    c.appendChild(m);

    if (a % 30 === 0) {
      const n = document.createElement('div');
      n.className = 'compass-number';
      let d;
      if (a === 0) d = '36';
      else if (a === 30) d = '03';
      else if (a === 60) d = '06';
      else if (a === 90) d = '09';
      else if (a === 120) d = '12';
      else if (a === 150) d = '15';
      else if (a === 180) d = '18';
      else if (a === 210) d = '21';
      else if (a === 240) d = '24';
      else if (a === 270) d = '27';
      else if (a === 300) d = '30';
      else if (a === 330) d = '33';
      n.textContent = d;
      const nr = rad + 15;
      const nx = cx + Math.cos(radian) * nr, ny = cy + Math.sin(radian) * nr;
      n.style.left = (nx - 12) + 'px';
      n.style.top = (ny - 8) + 'px';
      c.appendChild(n);
    }
  }

  if (currentRunwayData) {
    const rw = document.createElement('div');
    rw.className = 'runway-display';
    let runwayAngle;

    if (id === 'compass') {
      rw.classList.add('left-landing');
      const sel = document.getElementById('runwaySelect') ? document.getElementById('runwaySelect').value : '';
      if (sel) {
        runwayAngle = getRunwayHeading(sel) - 90;
      } else {
        runwayAngle = 0;
      }
    } else {
      rw.classList.add('left-landing');
      const opp = document.getElementById('runwayDisplay2') ? document.getElementById('runwayDisplay2').textContent : '';
      if (opp && opp !== '--') {
        runwayAngle = getRunwayHeading(opp) - 90;
      } else {
        runwayAngle = 0;
      }
    }

    rw.style.transform = `translate(-50%,-50%) rotate(${runwayAngle}deg)`;
    c.appendChild(rw);
  }

  if (currentMetarData && currentMetarData.wind.variable) {
    const ws = document.createElement('div');
    ws.className = 'wind-sector variable';
    c.appendChild(ws);
  }

  if (currentMetarData && !currentMetarData.wind.calm) {
    const wa = document.createElement('div');
    wa.className = 'wind-arrow';
    const windAngle = currentMetarData.wind.direction;
    const windRad = (windAngle - 90) * Math.PI / 180;
    const startX = cx + Math.cos(windRad) * (rad - 15);
    const startY = cy + Math.sin(windRad) * (rad - 15);
    wa.style.left = startX + 'px';
    wa.style.top = startY + 'px';
    wa.style.transform = `rotate(${windAngle}deg)`;
    c.appendChild(wa);
  }
}

// Обработка ввода ICAO с региональной отладкой
function handleIcaoInput() {
  const ii = document.getElementById('icaoInput');
  ii.addEventListener('input', async function() {
    const i = this.value.toUpperCase();
    this.value = i;

    if (i.length === 4) {
      if (!/^[A-Z0-9]{4}$/.test(i)) {
        updateConnectionStatus('error', 'Invalid ICAO code');
        return;
      }

      console.log(`🔄 Processing ICAO: ${i}`);
      updateConnectionStatus('loading', `Loading data for ${i}...`);

      try {
        // РАСШИРЕННЫЕ ЛОГИ ДЛЯ ОТЛАДКИ РЕГИОНАЛЬНЫХ ДАННЫХ
        const api = await getAPI();
        const airportInfo = api.getAirportInfo(i);

        if (airportInfo) {
          console.log(`📊 Airport info for ${i}:`);
          console.log(`   🏢 Name: ${airportInfo.name}`);
          console.log(`   🌍 Country: ${airportInfo.country}`);
          console.log(`   📍 Region: ${airportInfo.iso_region}`);
          console.log(`   🏙️ City: ${airportInfo.municipality}`);
          console.log(`   📍 Coordinates: ${airportInfo.latitude}, ${airportInfo.longitude}`);
          console.log(`   ⛰️ Elevation: ${airportInfo.elevation_ft}ft`);

          // Тестируем определение часового пояса
          const timezone = getAirportTimezoneFromCSV(i);
          console.log(`   ⏰ Calculated timezone: UTC${timezone >= 0 ? '+' : ''}${timezone}`);
        }

        // Загружаем данные ВПП
        await updateRunwayOptions(i);

        // Загружаем METAR данные
        currentMetarData = await fetchMetarData(i);
        updateWeatherDisplay(currentMetarData);

        // ОБНОВЛЯЕМ ДАННЫЕ ВОСХОДА/ЗАХОДА С РЕГИОНАЛЬНЫМИ ЧАСОВЫМИ ПОЯСАМИ
        await updateSunriseSunset();

        if (updateInterval) clearInterval(updateInterval);
        updateInterval = setInterval(async () => {
          try {
            currentMetarData = await fetchMetarData(i);
            updateWeatherDisplay(currentMetarData);
          } catch (error) {
            console.error('METAR auto-update failed:', error);
          }
        }, 30000);

        updateConnectionStatus('connected', `${i} data loaded`);
        console.log(`✅ Successfully loaded all data for ${i} with regional timezone support`);

      } catch (error) {
        console.error(`❌ Failed to load data for ${i}:`, error);
        updateConnectionStatus('error', `Failed to load ${i}`);
      }

    } else if (i.length === 0) {
      if (updateInterval) {
        clearInterval(updateInterval);
        updateInterval = null;
      }

      currentMetarData = null;
      currentRunwayData = null;

      const select = document.getElementById('runwaySelect');
      select.innerHTML = '<option value="">Enter ICAO code</option>';
      select.disabled = true;
      document.getElementById('runwayDisplay2').textContent = '--';

      initializeEmptyCompass('compass');
      initializeEmptyCompass('compass2');
      clearAllWeatherData();

      updateConnectionStatus('', 'Enter ICAO code');
      console.log('🔄 Cleared all data');

    } else {
      updateConnectionStatus('loading', `Type ${4 - i.length} more characters...`);
    }
  });
}

// Очистка всех погодных данных в UI
function clearAllWeatherData() {
  document.querySelectorAll('.weather-row .data-value').forEach(el => {
    if (!el.classList.contains('pressure-secondary')) {
      el.textContent = '-';
    }
  });
  document.querySelectorAll('.pressure-secondary').forEach(el => el.textContent = '-');

  document.getElementById('weatherPhenomena').textContent = '-';
  document.querySelector('#skyConditionLabel').parentElement.querySelector('.data-value').textContent = '-';
  document.getElementById('metarCode').textContent = '-';

  document.querySelectorAll('.lateral-component .data-value').forEach(el => el.textContent = '-');
  document.querySelectorAll('.headwind-component .data-value').forEach(el => el.textContent = '-');
  document.querySelectorAll('.friction-coefficient .data-value').forEach(el => el.textContent = '-');

  document.querySelectorAll('.wind-direction').forEach(el => el.textContent = '---°');
  document.querySelectorAll('.wind-speed').forEach(el => el.textContent = '-');

  document.querySelectorAll('.compass-info .rvr-row .data-value').forEach(el => el.textContent = '-');

  // Удаляем QFE и ELEV поля
  document.querySelectorAll('.qfe-row, .elev-row').forEach(row => row.remove());

  document.querySelectorAll('.forecast-value').forEach(el => el.textContent = '-');

  // ОЧИЩАЕМ ДАННЫЕ ВОСХОДА/ЗАХОДА
  document.getElementById('sunrise').textContent = '-';
  document.getElementById('sunset').textContent = '-';
  window.airportData = null;
}

// Вспомогательные функции
function updateTime() {
  const n = new Date();
  const u = n.toUTCString().substr(17, 5);
  document.getElementById('currentTime').textContent = u;
}

function applyTheme(t) {
  const b = document.body;
  const h = new Date().getHours();
  if (t === 'auto') {
    if (h >= 6 && h < 18) b.classList.remove('dark');
    else b.classList.add('dark');
  } else if (t === 'dark') b.classList.add('dark');
  else b.classList.remove('dark');
}

function toggleWindUnits() {
  const wu = document.querySelectorAll('.wind-unit');
  wu.forEach(u => {
    if (u.textContent === 'м/с') {
      u.textContent = 'kt';
      const se = document.querySelectorAll('.wind-speed');
      se.forEach(s => {
        const v = parseInt(s.textContent);
        if (!isNaN(v)) {
          const c = Math.round(v * 1.944);
          s.textContent = c.toString();
        }
      });
    } else {
      u.textContent = 'м/с';
      const se = document.querySelectorAll('.wind-speed');
      se.forEach(s => {
        const v = parseInt(s.textContent);
        if (!isNaN(v)) {
          const c = Math.round(v / 1.944);
          s.textContent = c.toString();
        }
      });
    }
  });
}

function applyLanguage(lang) {
  if (lang === 'ru') {
    document.getElementById('timeLabel').textContent = 'Время UTC';
    document.getElementById('sunriseLabel').textContent = 'Восход';
    document.getElementById('sunsetLabel').textContent = 'Заход';
    document.getElementById('weatherLabel').textContent = 'Явления погоды';
    document.getElementById('morLabel').textContent = 'Видимость';
    document.getElementById('qbbLabel').textContent = 'ВНГО';
    document.getElementById('skyConditionLabel').textContent = 'Облачность';
    document.getElementById('forecastLabel').textContent = 'Прогноз погоды';
    document.getElementById('specialLabel').textContent = 'Особые условия';
    document.getElementById('lateralLabel1').textContent = 'Боковая';
    document.getElementById('headwindLabel1').textContent = 'Встречная';
    document.getElementById('frictionLabel1').textContent = 'КСц';
    document.getElementById('lateralLabel2').textContent = 'Боковая';
    document.getElementById('headwindLabel2').textContent = 'Встречная';
    document.getElementById('frictionLabel2').textContent = 'КСц';
  } else {
    document.getElementById('timeLabel').textContent = 'Time UTC';
    document.getElementById('sunriseLabel').textContent = 'Sunrise';
    document.getElementById('sunsetLabel').textContent = 'Sunset';
    document.getElementById('weatherLabel').textContent = 'Weather';
    document.getElementById('morLabel').textContent = 'MOR';
    document.getElementById('qbbLabel').textContent = 'QBB';
    document.getElementById('skyConditionLabel').textContent = 'Sky condition';
    document.getElementById('forecastLabel').textContent = 'Weather forecast';
    document.getElementById('specialLabel').textContent = 'Special conditions';
    document.getElementById('lateralLabel1').textContent = 'Side';
    document.getElementById('headwindLabel1').textContent = 'Head';
    document.getElementById('frictionLabel1').textContent = 'Breaking action';
    document.getElementById('lateralLabel2').textContent = 'Side';
    document.getElementById('headwindLabel2').textContent = 'Head';
    document.getElementById('frictionLabel2').textContent = 'Breaking action';
  }
}

function initializeEmptyCompass(id) {
  const c = document.getElementById(id);
  c.innerHTML = '';
  const r = c.getBoundingClientRect();
  const s = Math.min(r.width, r.height);
  const rad = s / 2;
  const cx = s / 2, cy = s / 2;

  for (let i = 0; i < 36; i++) {
    const a = i * 10;
    const radian = (a - 90) * Math.PI / 180;
    const m = document.createElement('div');
    const maj = i % 3 === 0;
    m.className = maj ? 'compass-mark major' : 'compass-mark minor';
    const ml = maj ? 18 : 12, mw = maj ? 2 : 1;
    const or = rad - 1;
    const ox = cx + Math.cos(radian) * or, oy = cy + Math.sin(radian) * or;
    const ix = cx + Math.cos(radian) * (or - ml), iy = cy + Math.sin(radian) * (or - ml);
    const mcx = (ox + ix) / 2, mcy = (oy + iy) / 2;
    m.style.left = (mcx - mw / 2) + 'px';
    m.style.top = (mcy - ml / 2) + 'px';
    m.style.width = mw + 'px';
    m.style.height = ml + 'px';
    m.style.transform = `rotate(${a}deg)`;
    m.style.transformOrigin = 'center';
    c.appendChild(m);

    if (a % 30 === 0) {
      const n = document.createElement('div');
      n.className = 'compass-number';
      let d;
      if (a === 0) d = '36';
      else if (a === 30) d = '03';
      else if (a === 60) d = '06';
      else if (a === 90) d = '09';
      else if (a === 120) d = '12';
      else if (a === 150) d = '15';
      else if (a === 180) d = '18';
      else if (a === 210) d = '21';
      else if (a === 240) d = '24';
      else if (a === 270) d = '27';
      else if (a === 300) d = '30';
      else if (a === 330) d = '33';
      n.textContent = d;
      const nr = rad + 15;
      const nx = cx + Math.cos(radian) * nr, ny = cy + Math.sin(radian) * nr;
      n.style.left = (nx - 12) + 'px';
      n.style.top = (ny - 8) + 'px';
      c.appendChild(n);
    }
  }
}

// ТЕСТОВЫЕ ФУНКЦИИ ДЛЯ РЕГИОНАЛЬНЫХ ЧАСОВЫХ ПОЯСОВ
window.testAirportTimezone = function(icao = 'UUEE') {
  console.log(`🧪 Testing regional timezone for ${icao}...`);

  if (!globalAPI || !globalAPI.loaded) {
    console.error('❌ Airport database not loaded yet');
    return 'Database not loaded';
  }

  const airport = globalAPI.getAirportInfo(icao);
  if (!airport) {
    console.error(`❌ Airport ${icao} not found in database`);
    return 'Airport not found';
  }

  console.log(`📊 Airport details:`);
  console.log(`   🏢 Name: ${airport.name}`);
  console.log(`   🌍 Country: ${airport.country}`);
  console.log(`   📍 Region: ${airport.iso_region}`);
  console.log(`   🏙️ City: ${airport.municipality}`);
  console.log(`   📍 Coordinates: ${airport.latitude}, ${airport.longitude}`);

  const timezone = getTimezoneByRegion(airport);
  console.log(`   ⏰ Regional timezone: UTC${timezone >= 0 ? '+' : ''}${timezone}`);

  // Тестируем текущее время
  const now = new Date();
  const localTime = new Date(now.getTime() + (timezone * 3600000));
  console.log(`   🕐 Current UTC: ${now.toISOString().substr(11, 8)}`);
  console.log(`   🕐 Current local: ${localTime.toISOString().substr(11, 8)}`);

  return { airport: airport, regionalTimezone: timezone };
};

window.testMassTimezones = function() {
  console.log('🧪 Mass testing regional timezones...');

  if (!globalAPI || !globalAPI.loaded) {
    console.error('❌ Airport database not loaded yet');
    return 'Database not loaded';
  }

  const testIcaos = [
    // Россия - разные регионы
    'UUEE', 'ULLI', 'UMKK', 'USSS', 'UNNT', 'UHHH', 'UHPP',
    // Европа
    'EGLL', 'EDDF', 'LFPG', 'LIRF', 'LEMD', 'LSZH',
    // США - разные штаты
    'KJFK', 'KLAX', 'KORD', 'KDEN', 'KSEA', 'KIAH',
    // Другие страны
    'RJAA', 'ZBAA', 'VIDP', 'OMDB', 'YSSY', 'CYYZ'
  ];

  const results = [];
  let processed = 0;

  testIcaos.forEach(icao => {
    const airport = globalAPI.getAirportInfo(icao);
    if (!airport) {
      console.log(`❌ ${icao}: Not found`);
      return;
    }

    const regionalTz = getTimezoneByRegion(airport);
    console.log(`✅ ${icao} (${airport.iso_region}): UTC${regionalTz >= 0 ? '+' : ''}${regionalTz}`);

    results.push({
      icao,
      region: airport.iso_region,
      country: airport.country,
      city: airport.municipality,
      timezone: regionalTz
    });
    processed++;
  });

  console.log(`\n📊 Summary: ${processed} airports processed`);
  return results;
};

// Инициализация DOM
document.addEventListener('DOMContentLoaded', function() {
  initializeEmptyCompass('compass');
  initializeEmptyCompass('compass2');

  // Устанавливаем UTC время по умолчанию
  updateTime();

  // Основной интервал обновления UTC времени
  window.mainTimeInterval = setInterval(() => {
    const tl = document.getElementById('timeLabel');
    // Обновляем только если показывается UTC время
    if (tl && tl.textContent.includes('UTC')) {
      updateTime();
    }
  }, 1000);

  // Подключаем обработчики времени (из части 4A1)
  attachTimeClickHandlers();

  // Настраиваем интервал обновления времени который учитывает текущий режим
  setInterval(updateTimeDisplay, 1000);

  document.getElementById('theme').addEventListener('change', function() {
    applyTheme(this.value);
  });

  document.getElementById('language').addEventListener('change', function() {
    applyLanguage(this.value);
  });

  applyTheme('auto');
  applyLanguage('en');
  handleIcaoInput();

  document.getElementById('runwaySelect').addEventListener('change', function() {
    updateOppositeRunway();
  });

  document.querySelectorAll('.wind-unit').forEach(u => {
    u.addEventListener('click', toggleWindUnits);
  });

  window.addEventListener('resize', function() {
    setTimeout(() => {
      if (currentRunwayData && currentMetarData) {
        initializeCompass('compass');
        initializeCompass('compass2');
      } else if (currentRunwayData) {
        initializeCompassWithRunway('compass');
        initializeCompassWithRunway('compass2');
      } else {
        initializeEmptyCompass('compass');
        initializeEmptyCompass('compass2');
      }
    }, 100);
  });

  console.log('✅ Application initialized with regional timezone support');
});
</script>

<!-- ========== КОНЕЦ ЧАСТИ 4B ========== --><!-- ========== БЛОК 5A-1: ДЕКОДИРОВЩИК ПОГОДНЫХ УСЛОВИЙ - СЛОВАРИ ========== -->

<!-- Основан на WMO-4678 и приказе №115 от 5 марта 2015 -->

<script>
// ========== ПОЛНЫЙ ГИБРИДНЫЙ СЛОВАРЬ ПОГОДНЫХ УСЛОВИЙ ==========

const weatherHybridDictionary = {
  // ===== ПРОСТЫЕ ОСАДКИ С ИНТЕНСИВНОСТЬЮ =====
  "+DZ": { en: "Heavy Drizzle", ru: "Сильная морось" },
  "+RA": { en: "Heavy Rain", ru: "Сильный дождь" },
  "+SN": { en: "Heavy Snow", ru: "Сильный снег" },
  "+SG": { en: "Heavy Snow grains", ru: "Сильные снежные зёрна" },
  "+IC": { en: "Heavy Ice crystals", ru: "Сильные ледяные кристаллы" },
  "+PL": { en: "Heavy Ice pellets", ru: "Сильная ледяная крупа" },
  "+GR": { en: "Heavy Hail", ru: "Сильный град" },
  "+GS": { en: "Heavy Small hail", ru: "Сильный мелкий град" },
  "+UP": { en: "Heavy Unknown precipitation", ru: "Сильные неизвестные осадки" },

  "-DZ": { en: "Light Drizzle", ru: "Слабая морось" },
  "-RA": { en: "Light Rain", ru: "Слабый дождь" },
  "-SN": { en: "Light Snow", ru: "Слабый снег" },
  "-SG": { en: "Light Snow grains", ru: "Слабые снежные зёрна" },
  "-IC": { en: "Light Ice crystals", ru: "Слабые ледяные кристаллы" },
  "-PL": { en: "Light Ice pellets", ru: "Слабая ледяная крупа" },
  "-GR": { en: "Light Hail", ru: "Слабый град" },
  "-GS": { en: "Light Small hail", ru: "Слабый мелкий град" },
  "-UP": { en: "Light Unknown precipitation", ru: "Слабые неизвестные осадки" },

  "DZ": { en: "Drizzle", ru: "Морось" },
  "RA": { en: "Rain", ru: "Дождь" },
  "SN": { en: "Snow", ru: "Снег" },
  "SG": { en: "Snow grains", ru: "Снежные зёрна" },
  "IC": { en: "Ice crystals", ru: "Ледяные кристаллы" },
  "PL": { en: "Ice pellets", ru: "Ледяная крупа" },
  "GR": { en: "Hail", ru: "Град" },
  "GS": { en: "Small hail", ru: "Мелкий град" },
  "UP": { en: "Unknown precipitation", ru: "Неизвестные осадки" },

  // ===== СМЕШАННЫЕ ОСАДКИ =====
  "+DZRA": { en: "Heavy Drizzle and Rain", ru: "Сильная морось с дождём" },
  "+DZSN": { en: "Heavy Drizzle and Snow", ru: "Сильная морось со снегом" },
  "+DZSG": { en: "Heavy Drizzle and Snow grains", ru: "Сильная морось со снежными зёрнами" },
  "+DZIC": { en: "Heavy Drizzle and Ice crystals", ru: "Сильная морось с ледяными кристаллами" },
  "+DZPL": { en: "Heavy Drizzle and Ice pellets", ru: "Сильная морось с ледяной крупой" },
  "+DZGR": { en: "Heavy Drizzle and Hail", ru: "Сильная морось с градом" },
  "+DZGS": { en: "Heavy Drizzle and Small hail", ru: "Сильная морось с мелким градом" },

  "+RADZ": { en: "Heavy Rain and Drizzle", ru: "Сильный дождь с моросью" },
  "+RASN": { en: "Heavy Rain and Snow", ru: "Сильный дождь со снегом" },
  "+RASG": { en: "Heavy Rain and Snow grains", ru: "Сильный дождь со снежными зёрнами" },
  "+RAIC": { en: "Heavy Rain and Ice crystals", ru: "Сильный дождь с ледяными кристаллами" },
  "+RAPL": { en: "Heavy Rain and Ice pellets", ru: "Сильный дождь с ледяной крупой" },
  "+RAGR": { en: "Heavy Rain and Hail", ru: "Сильный дождь с градом" },
  "+RAGS": { en: "Heavy Rain and Small hail", ru: "Сильный дождь с мелким градом" },

  "+SNDZ": { en: "Heavy Snow and Drizzle", ru: "Сильный снег с моросью" },
  "+SNRA": { en: "Heavy Snow and Rain", ru: "Сильный снег с дождём" },
  "+SNSG": { en: "Heavy Snow and Snow grains", ru: "Сильный снег со снежными зёрнами" },
  "+SNIC": { en: "Heavy Snow and Ice crystals", ru: "Сильный снег с ледяными кристаллами" },
  "+SNPL": { en: "Heavy Snow and Ice pellets", ru: "Сильный снег с ледяной крупой" },
  "+SNGR": { en: "Heavy Snow and Hail", ru: "Сильный снег с градом" },
  "+SNGS": { en: "Heavy Snow and Small hail", ru: "Сильный снег с мелким градом" },

  "-DZRA": { en: "Light Drizzle and Rain", ru: "Слабая морось с дождём" },
  "-DZSN": { en: "Light Drizzle and Snow", ru: "Слабая морось со снегом" },
  "-RADZ": { en: "Light Rain and Drizzle", ru: "Слабый дождь с моросью" },
  "-RASN": { en: "Light Rain and Snow", ru: "Слабый дождь со снегом" },
  "-SNDZ": { en: "Light Snow and Drizzle", ru: "Слабый снег с моросью" },
  "-SNRA": { en: "Light Snow and Rain", ru: "Слабый снег с дождём" },
  "-PLSG": { en: "Light Ice pellets and Snow grains", ru: "Слабая ледяная крупа со снежными зёрнами" },
  "-SGPL": { en: "Light Snow grains and Ice pellets", ru: "Слабые снежные зёрна с ледяной крупой" },

  "DZRA": { en: "Drizzle and Rain", ru: "Морось с дождём" },
  "DZSN": { en: "Drizzle and Snow", ru: "Морось со снегом" },
  "DZPL": { en: "Drizzle and Ice pellets", ru: "Морось с ледяной крупой" },
  "DZSG": { en: "Drizzle and Snow grains", ru: "Морось со снежными зёрнами" },
  "DZIC": { en: "Drizzle and Ice crystals", ru: "Морось с ледяными кристаллами" },
  "DZGR": { en: "Drizzle and Hail", ru: "Морось с градом" },
  "DZGS": { en: "Drizzle and Small hail", ru: "Морось с мелким градом" },

  "RADZ": { en: "Rain and Drizzle", ru: "Дождь с моросью" },
  "RASN": { en: "Rain and Snow", ru: "Дождь со снегом" },
  "RAPL": { en: "Rain and Ice pellets", ru: "Дождь с ледяной крупой" },
  "RASG": { en: "Rain and Snow grains", ru: "Дождь со снежными зёрнами" },
  "RAIC": { en: "Rain and Ice crystals", ru: "Дождь с ледяными кристаллами" },
  "RAGR": { en: "Rain and Hail", ru: "Дождь с градом" },
  "RAGS": { en: "Rain and Small hail", ru: "Дождь с мелким градом" },

  "SNDZ": { en: "Snow and Drizzle", ru: "Снег с моросью" },
  "SNRA": { en: "Snow and Rain", ru: "Снег с дождём" },
  "SNPL": { en: "Snow and Ice pellets", ru: "Снег с ледяной крупой" },
  "SNSG": { en: "Snow and Snow grains", ru: "Снег со снежными зёрнами" },
  "SNIC": { en: "Snow and Ice crystals", ru: "Снег с ледяными кристаллами" },
  "SNGR": { en: "Snow and Hail", ru: "Снег с градом" },
  "SNGS": { en: "Snow and Small hail", ru: "Снег с мелким градом" },

  "SGDZ": { en: "Snow grains and Drizzle", ru: "Снежные зёрна с моросью" },
  "SGRA": { en: "Snow grains and Rain", ru: "Снежные зёрна с дождём" },
  "SGSN": { en: "Snow grains and Snow", ru: "Снежные зёрна со снегом" },
  "SGPL": { en: "Snow grains and Ice pellets", ru: "Снежные зёрна с ледяной крупой" },
  "SGIC": { en: "Snow grains and Ice crystals", ru: "Снежные зёрна с ледяными кристаллами" },
  "SGGR": { en: "Snow grains and Hail", ru: "Снежные зёрна с градом" },
  "SGGS": { en: "Snow grains and Small hail", ru: "Снежные зёрна с мелким градом" },

  "PLRA": { en: "Ice pellets and Rain", ru: "Ледяная крупа с дождём" },
  "PLSN": { en: "Ice pellets and Snow", ru: "Ледяная крупа со снегом" },
  "PLSG": { en: "Ice pellets and Snow grains", ru: "Ледяная крупа со снежными зёрнами" },
  "PLIC": { en: "Ice pellets and Ice crystals", ru: "Ледяная крупа с ледяными кристаллами" },
  "PLGR": { en: "Ice pellets and Hail", ru: "Ледяная крупа с градом" },
  "PLGS": { en: "Ice pellets and Small hail", ru: "Ледяная крупа с мелким градом" },

  "GRRA": { en: "Hail and Rain", ru: "Град с дождём" },
  "GRSN": { en: "Hail and Snow", ru: "Град со снегом" },
  "GRSG": { en: "Hail and Snow grains", ru: "Град со снежными зёрнами" },
  "GRIC": { en: "Hail and Ice crystals", ru: "Град с ледяными кристаллами" },
  "GRPL": { en: "Hail and Ice pellets", ru: "Град с ледяной крупой" },
  "GRGS": { en: "Hail and Small hail", ru: "Град с мелким градом" },

  "GSRA": { en: "Small hail and Rain", ru: "Мелкий град с дождём" },
  "GSSN": { en: "Small hail and Snow", ru: "Мелкий град со снегом" },
  "GSSG": { en: "Small hail and Snow grains", ru: "Мелкий град со снежными зёрнами" },
  "GSIC": { en: "Small hail and Ice crystals", ru: "Мелкий град с ледяными кристаллами" },
  "GSPL": { en: "Small hail and Ice pellets", ru: "Мелкий град с ледяной крупой" },
  "GSGR": { en: "Small hail and Hail", ru: "Мелкий град с градом" },

  // ===== ЛИВНЕВЫЕ ОСАДКИ =====
  "+SHDZ": { en: "Heavy Showers of Drizzle", ru: "Сильный ливневой дождь (морось)" },
  "+SHRA": { en: "Heavy Showers of Rain", ru: "Сильные ливни" },
  "+SHSN": { en: "Heavy Snow Showers", ru: "Сильные снежные заряды" },
  "+SHSG": { en: "Heavy Showers of Snow grains", ru: "Сильные ливневые снежные зёрна" },
  "+SHIC": { en: "Heavy Showers of Ice crystals", ru: "Сильные ливневые ледяные кристаллы" },
  "+SHPL": { en: "Heavy Showers of Ice pellets", ru: "Сильные ливневая ледяная крупа" },
  "+SHGR": { en: "Heavy Hail Showers", ru: "Сильные ливневый град" },
  "+SHGS": { en: "Heavy Small hail Showers", ru: "Сильные ливневый мелкий град" },

  "-SHDZ": { en: "Light Showers of Drizzle", ru: "Слабый ливневой дождь (морось)" },
  "-SHRA": { en: "Light Showers of Rain", ru: "Слабые ливни" },
  "-SHSN": { en: "Light Snow Showers", ru: "Слабые снежные заряды" },
  "-SHSG": { en: "Light Showers of Snow grains", ru: "Слабые ливневые снежные зёрна" },
  "-SHIC": { en: "Light Showers of Ice crystals", ru: "Слабые ливневые ледяные кристаллы" },
  "-SHPL": { en: "Light Showers of Ice pellets", ru: "Слабая ливневая ледяная крупа" },
  "-SHGR": { en: "Light Hail Showers", ru: "Слабый ливневый град" },
  "-SHGS": { en: "Light Small hail Showers", ru: "Слабый ливневый мелкий град" },

  "SHDZ": { en: "Showers of Drizzle", ru: "Ливневая морось" },
  "SHRA": { en: "Showers of Rain", ru: "Ливневой дождь" },
  "SHSN": { en: "Snow Showers", ru: "Снежные заряды" },
  "SHSG": { en: "Showers of Snow grains", ru: "Ливневые снежные зёрна" },
  "SHIC": { en: "Showers of Ice crystals", ru: "Ливневые ледяные кристаллы" },
  "SHPL": { en: "Showers of Ice pellets", ru: "Ливневая ледяная крупа" },
  "SHGR": { en: "Hail Showers", ru: "Ливневый град" },
  "SHGS": { en: "Small hail Showers", ru: "Ливневый мелкий град" },

  // ===== СМЕШАННЫЕ ЛИВНЕВЫЕ ОСАДКИ =====
  "SHRADZ": { en: "Showers of rain and drizzle", ru: "Ливни с дождём и моросью" },
  "SHRASN": { en: "Showers of rain and snow", ru: "Ливни с дождём и снегом" },
  "SHRASG": { en: "Showers of rain and snow grains", ru: "Ливни с дождём и снежными зёрнами" },
  "SHRAIC": { en: "Showers of rain and ice crystals", ru: "Ливни с дождём и ледяными кристаллами" },
  "SHRAPL": { en: "Showers of rain and ice pellets", ru: "Ливни с дождём и ледяной крупой" },
  "SHRAGR": { en: "Showers of rain and hail", ru: "Ливни с дождём и градом" },
  "SHRAGS": { en: "Showers of rain and small hail", ru: "Ливни с дождём и мелким градом" },

  "SHSNRA": { en: "Showers of snow and rain", ru: "Снежные заряды с дождём" },
  "SHSNDZ": { en: "Showers of snow and drizzle", ru: "Снежные заряды с моросью" },
  "SHSNSG": { en: "Showers of snow and snow grains", ru: "Снежные заряды со снежными зёрнами" },
  "SHSNIC": { en: "Showers of snow and ice crystals", ru: "Снежные заряды с ледяными кристаллами" },
  "SHSNPL": { en: "Showers of snow and ice pellets", ru: "Снежные заряды с ледяной крупой" },
  "SHSNGR": { en: "Showers of snow and hail", ru: "Снежные заряды с градом" },
  "SHSNGS": { en: "Showers of snow and small hail", ru: "Снежные заряды с мелким градом" },

  // ===== ГРОЗЫ =====
  "+TS": { en: "Heavy Thunderstorm", ru: "Сильная гроза" },
  "-TS": { en: "Light Thunderstorm", ru: "Слабая гроза" },
  "TS": { en: "Thunderstorm", ru: "Гроза" },

  "+TSDZ": { en: "Heavy Thunderstorm with Drizzle", ru: "Сильная гроза с моросью" },
  "+TSRA": { en: "Heavy Thunderstorm with Rain", ru: "Сильная гроза с дождём" },
  "+TSSN": { en: "Heavy Thunderstorm with Snow", ru: "Сильная гроза со снегом" },
  "+TSSG": { en: "Heavy Thunderstorm with Snow grains", ru: "Сильная гроза со снежными зёрнами" },
  "+TSIC": { en: "Heavy Thunderstorm with Ice crystals", ru: "Сильная гроза с ледяными кристаллами" },
  "+TSPL": { en: "Heavy Thunderstorm with Ice pellets", ru: "Сильная гроза с ледяной крупой" },
  "+TSGR": { en: "Heavy Thunderstorm with Hail", ru: "Сильная гроза с градом" },
  "+TSGS": { en: "Heavy Thunderstorm with Small hail", ru: "Сильная гроза с мелким градом" },
  "+TSUP": { en: "Heavy Thunderstorm with Unknown precipitation", ru: "Сильная гроза с неизвестными осадками" },

  "-TSDZ": { en: "Light Thunderstorm with Drizzle", ru: "Слабая гроза с моросью" },
  "-TSRA": { en: "Light Thunderstorm with Rain", ru: "Слабая гроза с дождём" },
  "-TSSN": { en: "Light Thunderstorm with Snow", ru: "Слабая гроза со снегом" },
  "-TSSG": { en: "Light Thunderstorm with Snow grains", ru: "Слабая гроза со снежными зёрнами" },
  "-TSIC": { en: "Light Thunderstorm with Ice crystals", ru: "Слабая гроза с ледяными кристаллами" },
  "-TSPL": { en: "Light Thunderstorm with Ice pellets", ru: "Слабая гроза с ледяной крупой" },
  "-TSGR": { en: "Light Thunderstorm with Hail", ru: "Слабая гроза с градом" },
  "-TSGS": { en: "Light Thunderstorm with Small hail", ru: "Слабая гроза с мелким градом" },
  "-TSUP": { en: "Light Thunderstorm with Unknown precipitation", ru: "Слабая гроза с неизвестными осадками" },

  "TSDZ": { en: "Thunderstorm with Drizzle", ru: "Гроза с моросью" },
  "TSRA": { en: "Thunderstorm with Rain", ru: "Гроза с дождём" },
  "TSSN": { en: "Thunderstorm with Snow", ru: "Гроза со снегом" },
  "TSSG": { en: "Thunderstorm with Snow grains", ru: "Гроза со снежными зёрнами" },
  "TSIC": { en: "Thunderstorm with Ice crystals", ru: "Гроза с ледяными кристаллами" },
  "TSPL": { en: "Thunderstorm with Ice pellets", ru: "Гроза с ледяной крупой" },
  "TSGR": { en: "Thunderstorm with Hail", ru: "Гроза с градом" },
  "TSGS": { en: "Thunderstorm with Small hail", ru: "Гроза с мелким градом" },
  "TSUP": { en: "Thunderstorm with Unknown precipitation", ru: "Гроза с неизвестными осадками" }
};
</script>

<!-- ========== КОНЕЦ БЛОКА 5A-1 ========== --> <!-- ========== БЛОК 5A-2: ДЕКОДИРОВЩИК - ПРОДОЛЖЕНИЕ СЛОВАРЕЙ ========== -->

<script>
// ===== ПРОДОЛЖЕНИЕ ГИБРИДНОГО СЛОВАРЯ =====

// Добавляем к существующему weatherHybridDictionary
Object.assign(weatherHybridDictionary, {
  // ===== СМЕШАННЫЕ ГРОЗЫ =====
  "TSRADZ": { en: "Thunderstorm with rain and drizzle", ru: "Гроза с дождём и моросью" },
  "TSRASN": { en: "Thunderstorm with rain and snow", ru: "Гроза с дождём и снегом" },
  "TSRASG": { en: "Thunderstorm with rain and snow grains", ru: "Гроза с дождём и снежными зёрнами" },
  "TSRAIC": { en: "Thunderstorm with rain and ice crystals", ru: "Гроза с дождём и ледяными кристаллами" },
  "TSRAPL": { en: "Thunderstorm with rain and ice pellets", ru: "Гроза с дождём и ледяной крупой" },
  "TSRAGR": { en: "Thunderstorm with rain and hail", ru: "Гроза с дождём и градом" },
  "TSRAGS": { en: "Thunderstorm with rain and small hail", ru: "Гроза с дождём и мелким градом" },

  "TSSNRA": { en: "Thunderstorm with snow and rain", ru: "Гроза со снегом и дождём" },
  "TSSNDZ": { en: "Thunderstorm with snow and drizzle", ru: "Гроза со снегом и моросью" },
  "TSSNSG": { en: "Thunderstorm with snow and snow grains", ru: "Гроза со снегом и снежными зёрнами" },
  "TSSNIC": { en: "Thunderstorm with snow and ice crystals", ru: "Гроза со снегом и ледяными кристаллами" },
  "TSSNPL": { en: "Thunderstorm with snow and ice pellets", ru: "Гроза со снегом и ледяной крупой" },
  "TSSNGR": { en: "Thunderstorm with snow and hail", ru: "Гроза со снегом и градом" },
  "TSSNGS": { en: "Thunderstorm with snow and small hail", ru: "Гроза со снегом и мелким градом" },

  // ===== ПЕРЕОХЛАЖДЁННЫЕ ОСАДКИ =====
  "+FZDZ": { en: "Heavy Freezing Drizzle", ru: "Сильная переохлаждённая морось" },
  "+FZRA": { en: "Heavy Freezing Rain", ru: "Сильный переохлаждённый дождь" },
  "+FZSN": { en: "Heavy Freezing Snow", ru: "Сильный переохлаждённый снег" },
  "+FZUP": { en: "Heavy Freezing Unknown precipitation", ru: "Сильные переохлаждённые неизвестные осадки" },

  "-FZDZ": { en: "Light Freezing Drizzle", ru: "Слабая переохлаждённая морось" },
  "-FZRA": { en: "Light Freezing Rain", ru: "Слабый переохлаждённый дождь" },
  "-FZSN": { en: "Light Freezing Snow", ru: "Слабый переохлаждённый снег" },
  "-FZUP": { en: "Light Freezing Unknown precipitation", ru: "Слабые переохлаждённые неизвестные осадки" },

  "FZDZ": { en: "Freezing Drizzle", ru: "Переохлаждённая морось" },
  "FZRA": { en: "Freezing Rain", ru: "Переохлаждённый дождь" },
  "FZSN": { en: "Freezing Snow", ru: "Переохлаждённый снег" },
  "FZUP": { en: "Freezing Unknown precipitation", ru: "Переохлаждённые неизвестные осадки" },

  "FZDZRA": { en: "Freezing Drizzle and Rain", ru: "Переохлаждённая морось с дождём" },
  "FZRASN": { en: "Freezing Rain and Snow", ru: "Переохлаждённый дождь со снегом" },
  "FZDZPL": { en: "Freezing Drizzle and Ice pellets", ru: "Переохлаждённая морось с ледяной крупой" },

  // ===== ТУМАНЫ И ДЫМКИ =====
  "+BR": { en: "Heavy Mist", ru: "Сильная дымка" },
  "+FG": { en: "Heavy Fog", ru: "Сильный туман" },
  "+FU": { en: "Heavy Smoke", ru: "Сильный дым" },
  "+VA": { en: "Heavy Volcanic ash", ru: "Сильный вулканический пепел" },
  "+DU": { en: "Heavy Dust", ru: "Сильная пыль" },
  "+SA": { en: "Heavy Sand", ru: "Сильный песок" },
  "+HZ": { en: "Heavy Haze", ru: "Сильная мгла" },
  "+PY": { en: "Heavy Spray", ru: "Сильная водяная пыль" },

  "-BR": { en: "Light Mist", ru: "Слабая дымка" },
  "-FG": { en: "Light Fog", ru: "Слабый туман" },
  "-FU": { en: "Light Smoke", ru: "Слабый дым" },
  "-VA": { en: "Light Volcanic ash", ru: "Слабый вулканический пепел" },
  "-DU": { en: "Light Dust", ru: "Слабая пыль" },
  "-SA": { en: "Light Sand", ru: "Слабый песок" },
  "-HZ": { en: "Light Haze", ru: "Слабая мгла" },
  "-PY": { en: "Light Spray", ru: "Слабая водяная пыль" },

  "BR": { en: "Mist", ru: "Дымка" },
  "FG": { en: "Fog", ru: "Туман" },
  "FU": { en: "Smoke", ru: "Дым" },
  "VA": { en: "Volcanic ash", ru: "Вулканический пепел" },
  "DU": { en: "Dust", ru: "Пыль" },
  "SA": { en: "Sand", ru: "Песок" },
  "HZ": { en: "Haze", ru: "Мгла" },
  "PY": { en: "Spray", ru: "Водяная пыль" },

  // ===== ТУМАНЫ С ДЕСКРИПТОРАМИ =====
  "MIFG": { en: "Shallow Fog", ru: "Поверхностный туман" },
  "PRFG": { en: "Partial Fog", ru: "Частичный туман" },
  "BCFG": { en: "Patches of Fog", ru: "Туман участками" },
  "FZFG": { en: "Freezing Fog", ru: "Переохлаждённый туман" },

  "MIBR": { en: "Shallow Mist", ru: "Поверхностная дымка" },
  "PRBR": { en: "Partial Mist", ru: "Частичная дымка" },
  "BCBR": { en: "Patches of Mist", ru: "Дымка участками" },

  // ===== МЕТЕЛИ И ПОЗЕМКИ =====
  "+BLSN": { en: "Heavy Blowing Snow", ru: "Сильная низовая метель" },
  "+DRSN": { en: "Heavy Drifting Snow", ru: "Сильный поземок" },
  "+BLDU": { en: "Heavy Blowing Dust", ru: "Сильная пыльная буря" },
  "+DRDU": { en: "Heavy Drifting Dust", ru: "Сильный поземок пыли" },
  "+BLSA": { en: "Heavy Blowing Sand", ru: "Сильная песчаная буря" },
  "+DRSA": { en: "Heavy Drifting Sand", ru: "Сильный поземок песка" },

  "-BLSN": { en: "Light Blowing Snow", ru: "Слабая низовая метель" },
  "-DRSN": { en: "Light Drifting Snow", ru: "Слабый поземок" },
  "-BLDU": { en: "Light Blowing Dust", ru: "Слабая пыльная буря" },
  "-DRDU": { en: "Light Drifting Dust", ru: "Слабый поземок пыли" },
  "-BLSA": { en: "Light Blowing Sand", ru: "Слабая песчаная буря" },
  "-DRSA": { en: "Light Drifting Sand", ru: "Слабый поземок песка" },

  "BLSN": { en: "Blowing Snow", ru: "Низовая метель" },
  "DRSN": { en: "Drifting Snow", ru: "Поземок" },
  "BLDU": { en: "Blowing Dust", ru: "Пыльная буря" },
  "DRDU": { en: "Drifting Dust", ru: "Поземок пыли" },
  "BLSA": { en: "Blowing Sand", ru: "Песчаная буря" },
  "DRSA": { en: "Drifting Sand", ru: "Поземок песка" }
});
</script>

<!-- ========== КОНЕЦ БЛОКА 5A-2 ========== --> <!-- ========== БЛОК 5A-3: ДЕКОДИРОВЩИК - ЗАВЕРШЕНИЕ СЛОВАРЕЙ ========== -->

<script>
// ===== ЗАВЕРШЕНИЕ ГИБРИДНОГО СЛОВАРЯ =====

// Добавляем к существующему weatherHybridDictionary
Object.assign(weatherHybridDictionary, {
  // ===== ДРУГИЕ ЯВЛЕНИЯ =====
  "+PO": { en: "Heavy Dust/Sand whirls", ru: "Сильные пыльные/песчаные вихри" },
  "+SQ": { en: "Heavy Squalls", ru: "Сильные шквалы" },
  "+FC": { en: "Heavy Funnel cloud/Tornado/Waterspout", ru: "Сильный смерч/торнадо" },
  "+SS": { en: "Heavy Sandstorm", ru: "Сильная песчаная буря" },
  "+DS": { en: "Heavy Duststorm", ru: "Сильная пыльная буря" },

  "-PO": { en: "Light Dust/Sand whirls", ru: "Слабые пыльные/песчаные вихри" },
  "-SQ": { en: "Light Squalls", ru: "Слабые шквалы" },
  "-FC": { en: "Light Funnel cloud/Tornado/Waterspout", ru: "Слабый смерч/торнадо" },
  "-SS": { en: "Light Sandstorm", ru: "Слабая песчаная буря" },
  "-DS": { en: "Light Duststorm", ru: "Слабая пыльная буря" },

  "PO": { en: "Dust/Sand whirls", ru: "Пыльные/песчаные вихри" },
  "SQ": { en: "Squalls", ru: "Шквалы" },
  "FC": { en: "Funnel cloud/Tornado/Waterspout", ru: "Смерч/торнадо" },
  "SS": { en: "Sandstorm", ru: "Песчаная буря" },
  "DS": { en: "Duststorm", ru: "Пыльная буря" },

  // ===== В ОКРЕСТНОСТИ (VICINITY) =====
  "VCTS": { en: "Thunderstorm in vicinity", ru: "Гроза в окрестности" },
  "VCTSRA": { en: "Thunderstorm with rain in vicinity", ru: "Гроза с дождём в окрестности" },
  "VCTSSN": { en: "Thunderstorm with snow in vicinity", ru: "Гроза со снегом в окрестности" },
  "VCTSGR": { en: "Thunderstorm with hail in vicinity", ru: "Гроза с градом в окрестности" },
  "VCTSPL": { en: "Thunderstorm with ice pellets in vicinity", ru: "Гроза с ледяной крупой в окрестности" },

  "VCSH": { en: "Showers in vicinity", ru: "Ливни в окрестности" },
  "VCSHRA": { en: "Rain showers in vicinity", ru: "Ливневой дождь в окрестности" },
  "VCSHSN": { en: "Snow showers in vicinity", ru: "Снежные заряды в окрестности" },
  "VCSHGR": { en: "Hail showers in vicinity", ru: "Ливневой град в окрестности" },

  "VCFG": { en: "Fog in vicinity", ru: "Туман в окрестности" },
  "VCBR": { en: "Mist in vicinity", ru: "Дымка в окрестности" },
  "VCFU": { en: "Smoke in vicinity", ru: "Дым в окрестности" },
  "VCVA": { en: "Volcanic ash in vicinity", ru: "Вулканический пепел в окрестности" },
  "VCDU": { en: "Dust in vicinity", ru: "Пыль в окрестности" },
  "VCSA": { en: "Sand in vicinity", ru: "Песок в окрестности" },
  "VCHZ": { en: "Haze in vicinity", ru: "Мгла в окрестности" },

  "VCPO": { en: "Dust/Sand whirls in vicinity", ru: "Пыльные/песчаные вихри в окрестности" },
  "VCFC": { en: "Funnel cloud in vicinity", ru: "Воронкообразное облако в окрестности" },
  "VCSS": { en: "Sandstorm in vicinity", ru: "Песчаная буря в окрестности" },
  "VCDS": { en: "Duststorm in vicinity", ru: "Пыльная буря в окрестности" },

  "VCBLSN": { en: "Blowing snow in vicinity", ru: "Низовая метель в окрестности" },
  "VCDRSN": { en: "Drifting snow in vicinity", ru: "Поземок в окрестности" },
  "VCBLDU": { en: "Blowing dust in vicinity", ru: "Пыльная буря в окрестности" },
  "VCBLSA": { en: "Blowing sand in vicinity", ru: "Песчаная буря в окрестности" },

  "VCFZRA": { en: "Freezing rain in vicinity", ru: "Переохлаждённый дождь в окрестности" },
  "VCFZDZ": { en: "Freezing drizzle in vicinity", ru: "Переохлаждённая морось в окрестности" },
  "VCFZFG": { en: "Freezing fog in vicinity", ru: "Переохлаждённый туман в окрестности" },

  // ===== РЕДКИЕ И ОСОБЫЕ КОМБИНАЦИИ =====
  "SHFZRA": { en: "Showers of freezing rain", ru: "Ливневой переохлаждённый дождь" },
  "SHFZDZ": { en: "Showers of freezing drizzle", ru: "Ливневая переохлаждённая морось" },
  "TSFZRA": { en: "Thunderstorm with freezing rain", ru: "Гроза с переохлаждённым дождём" },
  "TSFZDZ": { en: "Thunderstorm with freezing drizzle", ru: "Гроза с переохлаждённой моросью" },

  "FGBR": { en: "Fog and Mist", ru: "Туман с дымкой" },
  "BRFG": { en: "Mist and Fog", ru: "Дымка с туманом" },
  "FUDU": { en: "Smoke and Dust", ru: "Дым с пылью" },
  "DUFU": { en: "Dust and Smoke", ru: "Пыль с дымом" },
  "SADU": { en: "Sand and Dust", ru: "Песок с пылью" },
  "DUSA": { en: "Dust and Sand", ru: "Пыль с песком" },

  // ===== ТРОЙНЫЕ КОМБИНАЦИИ =====
  "TSRAGRSN": { en: "Thunderstorm with rain, hail and snow", ru: "Гроза с дождём, градом и снегом" },
  "SHRASNPL": { en: "Showers of rain, snow and ice pellets", ru: "Ливни с дождём, снегом и ледяной крупой" },
  "RASNSG": { en: "Rain, snow and snow grains", ru: "Дождь, снег и снежные зёрна" },
  "DZRAPL": { en: "Drizzle, rain and ice pellets", ru: "Морось, дождь и ледяная крупа" },

  // ===== СПЕЦИАЛЬНЫЕ АВТОМАТИЧЕСКИЕ КОДЫ =====
  "AUTO": { en: "Automated observation", ru: "Автоматическое наблюдение" },
  "COR": { en: "Corrected observation", ru: "Исправленное наблюдение" },
  "NIL": { en: "No data", ru: "Нет данных" },
  "NSW": { en: "No significant weather", ru: "Без особых явлений погоды" },
  "TEMPO": { en: "Temporary conditions", ru: "Временные условия" },
  "BECMG": { en: "Becoming conditions", ru: "Ожидаемые изменения" },

  // ===== ИНТЕНСИВНОСТЬ БЕЗ ЯВЛЕНИЙ =====
  "RE": { en: "Recent weather", ru: "Недавняя погода" },
  "+RE": { en: "Heavy recent weather", ru: "Сильные недавние явления" },
  "-RE": { en: "Light recent weather", ru: "Слабые недавние явления" }
});

// ===== КАРТЫ ДЛЯ КОМПОНЕНТНОГО АНАЛИЗА =====
const weatherIntensityMap = {
  "+": { en: "Heavy", ru: "Сильный" },
  "-": { en: "Light", ru: "Слабый" }
};

const weatherDescriptorMap = {
  MI: { en: "Shallow", ru: "Поверхностный" },
  BC: { en: "Patches", ru: "Участками" },
  PR: { en: "Partial", ru: "Частичный" },
  DR: { en: "Low drifting", ru: "Поземок" },
  BL: { en: "Blowing", ru: "Низовая метель/буря" },
  SH: { en: "Showers", ru: "Ливневый" },
  TS: { en: "Thunderstorm", ru: "Гроза" },
  FZ: { en: "Freezing", ru: "Переохлаждённый" },
  VC: { en: "In the vicinity", ru: "В окрестности" }
};

const weatherPhenomenaMap = {
  // Осадки
  DZ: { en: "Drizzle", ru: "Морось" },
  RA: { en: "Rain", ru: "Дождь" },
  SN: { en: "Snow", ru: "Снег" },
  SG: { en: "Snow grains", ru: "Снежные зёрна" },
  IC: { en: "Ice crystals", ru: "Ледяные кристаллы" },
  PL: { en: "Ice pellets", ru: "Ледяная крупа" },
  GR: { en: "Hail", ru: "Град" },
  GS: { en: "Small hail", ru: "Мелкий град" },
  UP: { en: "Unknown precipitation", ru: "Неизвестные осадки" },

  // Замутнение
  BR: { en: "Mist", ru: "Дымка" },
  FG: { en: "Fog", ru: "Туман" },
  FU: { en: "Smoke", ru: "Дым" },
  VA: { en: "Volcanic ash", ru: "Вулканический пепел" },
  DU: { en: "Dust", ru: "Пыль" },
  SA: { en: "Sand", ru: "Песок" },
  HZ: { en: "Haze", ru: "Мгла" },
  PY: { en: "Spray", ru: "Водяная пыль" },

  // Другие явления
  SQ: { en: "Squalls", ru: "Шквалы" },
  FC: { en: "Funnel cloud/Tornado", ru: "Смерч/торнадо" },
  SS: { en: "Sandstorm", ru: "Песчаная буря" },
  DS: { en: "Duststorm", ru: "Пыльная буря" },
  PO: { en: "Dust/Sand whirls", ru: "Пыльные/песчаные вихри" }
};

// Функция декодирования одного токена (как в примере)
function decodeWeatherToken(token, language = 'ru') {
  const lang = language === 'en' ? 'en' : 'ru';

  if (weatherHybridDictionary[token]) {
    const { en, ru } = weatherHybridDictionary[token];
    return `<b>${token}</b><br>EN: ${en}<br>RU: ${ru}`;
  }

  // Разбор по частям (если нет в словаре)
  let original = token;
  let intensity = "";
  let descriptor = "";
  let phenomena = "";

  if (token.length >= 2 && (token[0] === "+" || token[0] === "-")) {
    intensity = token[0];
    token = token.slice(1);
  }

  // Проверяем VC в начале
  if (token.startsWith("VC")) {
    descriptor = "VC";
    token = token.slice(2);
  } else {
    // Проверяем другие дескрипторы
    for (let code of Object.keys(weatherDescriptorMap)) {
      if (token.startsWith(code)) {
        descriptor = code;
        token = token.slice(code.length);
        break;
      }
    }
  }

  // Пытаемся найти два явления
  let ph1 = token.slice(0, 2);
  let ph2 = token.slice(2, 4);

  if (weatherPhenomenaMap[ph1] && weatherPhenomenaMap[ph2]) {
    phenomena = `${weatherPhenomenaMap[ph1][lang]} и ${weatherPhenomenaMap[ph2][lang]}`;
    let phenomenaEn = `${weatherPhenomenaMap[ph1].en} and ${weatherPhenomenaMap[ph2].en}`;

    let intensityText = weatherIntensityMap[intensity]?.[lang] || "";
    let intensityTextEn = weatherIntensityMap[intensity]?.en || "";
    let descriptorText = weatherDescriptorMap[descriptor]?.[lang] || "";
    let descriptorTextEn = weatherDescriptorMap[descriptor]?.en || "";

    return `<b>${original}</b><br>EN: ${intensityTextEn} ${descriptorTextEn} ${phenomenaEn}<br>RU: ${intensityText} ${descriptorText} ${phenomena}`;

  } else if (weatherPhenomenaMap[token]) {
    // Одно явление
    phenomena = weatherPhenomenaMap[token];

    let intensityText = weatherIntensityMap[intensity]?.[lang] || "";
    let intensityTextEn = weatherIntensityMap[intensity]?.en || "";
    let descriptorText = weatherDescriptorMap[descriptor]?.[lang] || "";
    let descriptorTextEn = weatherDescriptorMap[descriptor]?.en || "";

    return `<b>${original}</b><br>EN: ${intensityTextEn} ${descriptorTextEn} ${phenomena.en}<br>RU: ${intensityText} ${descriptorText} ${phenomena.ru}`;
  }

  return `<b>${original}</b><br><span style="color:gray">Неизвестный код / Unknown code</span>`;
}

// Основная функция декодирования (как в примере)
function decodeWeatherCodes(input, language = 'ru') {
  if (!input) {
    return "Введите хотя бы один код / Enter at least one code";
  }

  const tokens = input.toUpperCase().trim().split(/\s+/);
  const outputs = tokens.map(token => decodeWeatherToken(token, language));
  return outputs.join("<hr>");
}
</script>

<!-- ========== КОНЕЦ БЛОКА 5A-3 ========== --><!-- ========== БЛОК 5B: ИНТЕГРАЦИЯ ДЕКОДИРОВЩИКА ПОГОДНЫХ УСЛОВИЙ (ИЗМЕНЕННЫЙ) ========== -->

<!-- Замена функций обновления погодных данных -->

<script>
// ========== УПРОЩЕННАЯ ИНТЕГРАЦИЯ ДЕКОДИРОВЩИКА БЕЗ ДУБЛИРОВАНИЙ ==========

// ПРИМЕЧАНИЕ: Основная функция updateWeatherDisplay() находится в блоке 6B-1
// Здесь оставляем только вспомогательные функции которых нет в других блоках

console.log('✅ Weather decoder integration loaded (helper functions only)');
</script>

<!-- ========== КОНЕЦ БЛОКА 5B ========== --><!-- ========== ИСПРАВЛЕННЫЙ БЛОК 6A: ДЕКОДИРОВЩИК ОБЛАЧНОСТИ С ПРЕДЛОГАМИ ========== -->

<script>
// ========== ДЕКОДИРОВЩИК ОБЛАЧНОСТИ METAR С ПРЕДЛОГАМИ ==========

class CloudDecoder {
    constructor() {
        this.language = 'en';
        this.initializeCloudCodes();
    }

    initializeCloudCodes() {
        // ===== КОДЫ ПОКРЫТИЯ НЕБА =====
        this.coverageCodes = {
            'SKC': {
                en: 'Sky Clear',
                ru: 'Ясно',
                description: {
                    en: 'No clouds below 12,000 feet',
                    ru: 'Облаков ниже 12000 футов нет'
                },
                priority: 1
            },
            'CLR': {
                en: 'Clear',
                ru: 'Ясно',
                description: {
                    en: 'No clouds below 12,000 feet (automated)',
                    ru: 'Облаков ниже 12000 футов нет (автоматическое)'
                },
                priority: 1
            },
            'NSC': {
                en: 'No Significant Cloud',
                ru: 'Нет значимых облаков',
                description: {
                    en: 'No cloud below 5,000 feet and no cumulonimbus or towering cumulus',
                    ru: 'Облаков ниже 5000 футов нет, кучево-дождевых и мощных кучевых нет'
                },
                priority: 1
            },
            'NCD': {
                en: 'No Cloud Detected',
                ru: 'Облака не обнаружены',
                description: {
                    en: 'No cloud detected by automated system',
                    ru: 'Облака не обнаружены автоматической системой'
                },
                priority: 1
            },
            'FEW': {
                en: 'Few',
                ru: 'Незначительные',
                description: {
                    en: 'Cloud coverage 1/8 to 2/8 of sky',
                    ru: 'Покрытие неба 1/8-2/8'
                },
                priority: 2,
                coverage: '1-2 окта'
            },
            'SCT': {
                en: 'Scattered',
                ru: 'Рассеянные',
                description: {
                    en: 'Cloud coverage 3/8 to 4/8 of sky',
                    ru: 'Покрытие неба 3/8-4/8'
                },
                priority: 3,
                coverage: '3-4 окта'
            },
            'BKN': {
                en: 'Broken',
                ru: 'Значительные',
                description: {
                    en: 'Cloud coverage 5/8 to 7/8 of sky',
                    ru: 'Покрытие неба 5/8-7/8'
                },
                priority: 4,
                coverage: '5-7 окт'
            },
            'OVC': {
                en: 'Overcast',
                ru: 'Сплошные',
                description: {
                    en: 'Cloud coverage 8/8 of sky',
                    ru: 'Покрытие неба 8/8'
                },
                priority: 5,
                coverage: '8 окт'
            },
            '///': {
                en: 'Cloud data not available',
                ru: 'Данные о облачности недоступны',
                description: {
                    en: 'Cloud information not available',
                    ru: 'Информация об облачности недоступна'
                },
                priority: 0
            }
        };

        // ===== ТИПЫ ОБЛАКОВ =====
        this.cloudTypes = {
            'CB': {
                en: 'Cumulonimbus',
                ru: 'кучево-дождевые',
                description: {
                    en: 'Cumulonimbus clouds (thunderstorm clouds)',
                    ru: 'Кучево-дождевые облака (грозовые облака)'
                },
                priority: 10,
                significant: true
            },
            'TCU': {
                en: 'Towering Cumulus',
                ru: 'мощные кучевые',
                description: {
                    en: 'Towering Cumulus clouds',
                    ru: 'Мощные кучевые облака'
                },
                priority: 9,
                significant: true
            },
            'CBMAM': {
                en: 'Cumulonimbus Mammatus',
                ru: 'кучево-дождевые вымеобразные',
                description: {
                    en: 'Cumulonimbus with mammatus',
                    ru: 'Кучево-дождевые с выменеобразными выростами'
                },
                priority: 11,
                significant: true
            }
        };

        // ===== ОСОБЫЕ КОДЫ ОБЛАЧНОСТИ =====
        this.specialCodes = {
            'CAVOK': {
                en: 'Ceiling and Visibility OK',
                ru: 'Потолок и видимость в норме',
                description: {
                    en: 'Visibility ≥10km, no cloud below 5,000ft, no significant weather',
                    ru: 'Видимость ≥10км, облаков ниже 5000 футов нет, особых явлений нет'
                }
            },
            'VV': {
                en: 'Vertical Visibility',
                ru: 'Вертикальная видимость',
                description: {
                    en: 'Sky obscured, vertical visibility only',
                    ru: 'Небо закрыто, только вертикальная видимость'
                }
            }
        };
    }

    // Установка языка
    setLanguage(lang) {
        this.language = lang;
    }

    // Основная функция декодирования облачности
    decodeCloudiness(metarClouds) {
        if (!metarClouds || metarClouds.length === 0) {
            return {
                summary: this.language === 'ru' ? 'Нет данных' : 'No data',
                layers: [],
                ceiling: null,
                significantClouds: [],
                weatherImpact: 'none'
            };
        }

        // Проверяем специальные коды
        for (const cloud of metarClouds) {
            if (typeof cloud === 'string') {
                const specialResult = this.decodeSpecialCloudCode(cloud);
                if (specialResult) return specialResult;
            }
        }

        // Декодируем слои облаков
        const layers = [];
        let ceiling = null;
        const significantClouds = [];

        for (const cloud of metarClouds) {
            if (typeof cloud === 'object' && cloud.coverage && cloud.height !== undefined) {
                const decodedLayer = this.decodeCloudLayer(cloud);
                if (decodedLayer) {
                    layers.push(decodedLayer);

                    // Определяем потолок (первый слой BKN или OVC)
                    if (!ceiling && (cloud.coverage === 'BKN' || cloud.coverage === 'OVC')) {
                        ceiling = {
                            height: cloud.height,
                            coverage: decodedLayer.coverage,
                            type: decodedLayer.type
                        };
                    }

                    // Собираем значимые облака
                    if (decodedLayer.significant) {
                        significantClouds.push(decodedLayer);
                    }
                }
            }
        }

        // Формируем итоговое описание
        const summary = this.generateCloudSummary(layers, ceiling, significantClouds);
        const weatherImpact = this.assessWeatherImpact(layers, significantClouds);

        return {
            summary: summary,
            layers: layers,
            ceiling: ceiling,
            significantClouds: significantClouds,
            weatherImpact: weatherImpact,
            details: this.generateDetailedDescription(layers)
        };
    }

    // Декодирование специальных кодов
    decodeSpecialCloudCode(code) {
        const upperCode = code.toUpperCase();

        if (this.specialCodes[upperCode]) {
            const special = this.specialCodes[upperCode];
            return {
                summary: special[this.language],
                layers: [{
                    code: upperCode,
                    description: special[this.language],
                    details: special.description[this.language],
                    special: true
                }],
                ceiling: null,
                significantClouds: [],
                weatherImpact: upperCode === 'CAVOK' ? 'good' : 'limited'
            };
        }

        // Проверяем коды покрытия без высоты
        if (this.coverageCodes[upperCode]) {
            const coverage = this.coverageCodes[upperCode];
            return {
                summary: coverage[this.language],
                layers: [{
                    code: upperCode,
                    description: coverage[this.language],
                    details: coverage.description[this.language],
                    special: true
                }],
                ceiling: null,
                significantClouds: [],
                weatherImpact: ['SKC', 'CLR', 'NSC'].includes(upperCode) ? 'good' : 'unknown'
            };
        }

        // Вертикальная видимость
        const vvMatch = upperCode.match(/^VV(\d{3})$/);
        if (vvMatch) {
            const height = parseInt(vvMatch[1]) * 100;
            return {
                summary: this.language === 'ru' ?
                    `Вертикальная видимость ${height} футов` :
                    `Vertical visibility ${height} feet`,
                layers: [{
                    code: upperCode,
                    height: height,
                    description: this.specialCodes['VV'][this.language],
                    details: this.specialCodes['VV'].description[this.language],
                    special: true
                }],
                ceiling: { height: height, coverage: 'Obscured', type: null },
                significantClouds: [],
                weatherImpact: 'poor'
            };
        }

        return null;
    }

    // Декодирование отдельного слоя облаков
    decodeCloudLayer(cloud) {
        if (!cloud.coverage) return null;

        const coverage = this.coverageCodes[cloud.coverage];
        if (!coverage) return null;

        const layer = {
            code: `${cloud.coverage}${cloud.height ? String(Math.round(cloud.height/100)).padStart(3, '0') : ''}`,
            coverage: coverage[this.language],
            coverageCode: cloud.coverage,
            height: cloud.height,
            heightText: this.formatHeight(cloud.height),
            description: coverage.description[this.language],
            priority: coverage.priority,
            significant: false,
            type: null,
            typeDescription: null
        };

        // Добавляем тип облаков если указан
        if (cloud.type && this.cloudTypes[cloud.type]) {
            const cloudType = this.cloudTypes[cloud.type];
            layer.type = cloudType[this.language];
            layer.typeDescription = cloudType.description[this.language];
            layer.significant = cloudType.significant;
            layer.priority = Math.max(layer.priority, cloudType.priority);
        }

        return layer;
    }

    // Форматирование высоты
    formatHeight(height) {
        if (height === null || height === undefined) return '';

        if (this.language === 'ru') {
            return `${height} фт`;
        } else {
            return `${height} ft`;
        }
    }

    // Генерация краткого описания облачности С ПРЕДЛОГАМИ И ПЕРЕНОСАМИ СТРОК
    generateCloudSummary(layers, ceiling, significantClouds) {
        if (layers.length === 0) {
            return this.language === 'ru' ? 'Нет данных' : 'No data';
        }

        // Если есть специальный слой
        const specialLayer = layers.find(layer => layer.special);
        if (specialLayer) {
            return this.formatFirstWordCapital(specialLayer.description);
        }

        // ИСПРАВЛЕНО: Показываем ВСЕ слои облачности С ПРЕДЛОГАМИ И ПЕРЕНОСАМИ
        const layerDescriptions = layers.map(layer => {
            const typeText = layer.type ? ` ${layer.type}` : '';
            const preposition = this.language === 'ru' ? 'на' : 'at';

            if (layer.height && layer.height > 0) {
                return `${layer.coverage.toLowerCase()}${typeText} ${preposition} ${layer.heightText}`;
            } else {
                return `${layer.coverage.toLowerCase()}${typeText}`;
            }
        });

        // НОВОЕ: Объединяем все слои с переносом строки после каждой запятой
        const allLayers = layerDescriptions.join(',<br>');

        return this.formatFirstWordCapital(allLayers);
    }

    // Новая функция для форматирования первого слова с заглавной
    formatFirstWordCapital(text) {
        if (!text || text.trim() === '') return '';

        const trimmed = text.trim();
        return trimmed.charAt(0).toUpperCase() + trimmed.slice(1);
    }

    // Оценка влияния на полеты
    assessWeatherImpact(layers, significantClouds) {
        // Если есть CB или TCU - плохие условия
        if (significantClouds.some(cloud => cloud.type && (cloud.type.includes('кучево-дождевые') || cloud.type.includes('Cumulonimbus')))) {
            return 'severe';
        }

        if (significantClouds.some(cloud => cloud.type && (cloud.type.includes('мощные кучевые') || cloud.type.includes('Towering')))) {
            return 'moderate';
        }

        // Если есть низкий потолок
        const lowCeiling = layers.find(layer =>
            (layer.coverageCode === 'BKN' || layer.coverageCode === 'OVC') &&
            layer.height && layer.height < 1000
        );

        if (lowCeiling) return 'poor';

        // Если есть сплошная облачность
        const overcast = layers.find(layer => layer.coverageCode === 'OVC');
        if (overcast) return 'moderate';

        // Если есть значительная облачность
        const broken = layers.find(layer => layer.coverageCode === 'BKN');
        if (broken) return 'fair';

        // Ясно или незначительная облачность
        return 'good';
    }

    // Генерация подробного описания
    generateDetailedDescription(layers) {
        if (layers.length === 0) return '';

        return layers.map(layer => {
            let detail = `${layer.coverage}`;

            if (layer.height) {
                detail += ` на высоте ${layer.heightText}`;
            }

            if (layer.type) {
                detail += ` (${layer.type})`;
            }

            return detail;
        }).join('; ');
    }

    // Парсинг облачности из строки METAR
    parseCloudStringFromMETAR(metarString) {
        const clouds = [];
        const parts = metarString.split(/\s+/);

        for (const part of parts) {
            // Специальные коды
            if (['SKC', 'CLR', 'NSC', 'NCD', 'CAVOK'].includes(part)) {
                clouds.push(part);
                continue;
            }

            // Вертикальная видимость
            if (part.match(/^VV\d{3}$/)) {
                clouds.push(part);
                continue;
            }

            // Обычные слои облаков
            const cloudMatch = part.match(/^(FEW|SCT|BKN|OVC)(\d{3})(CB|TCU|CBMAM)?$/);
            if (cloudMatch) {
                const coverage = cloudMatch[1];
                const height = parseInt(cloudMatch[2]) * 100;
                const type = cloudMatch[3] || null;

                clouds.push({
                    coverage: coverage,
                    height: height,
                    type: type
                });
            }

            // Неопределенная облачность
            if (part === '///') {
                clouds.push(part);
            }
        }

        return clouds;
    }

    // Получение потолка в футах (для других расчетов)
    getCeilingHeight(decodedClouds) {
        if (!decodedClouds.ceiling) return null;
        return decodedClouds.ceiling.height;
    }

    // Проверка наличия значимых облаков
    hasSignificantClouds(decodedClouds) {
        return decodedClouds.significantClouds && decodedClouds.significantClouds.length > 0;
    }

    // Получение самого низкого слоя
    getLowestLayer(decodedClouds) {
        if (!decodedClouds.layers || decodedClouds.layers.length === 0) return null;

        const layersWithHeight = decodedClouds.layers.filter(layer => layer.height !== null);
        if (layersWithHeight.length === 0) return null;

        return layersWithHeight.reduce((lowest, current) =>
            current.height < lowest.height ? current : lowest
        );
    }
}

// Создаем глобальный экземпляр декодировщика облачности
window.cloudDecoder = new CloudDecoder();

// Функции для интеграции в основное приложение
window.decodeCloudiness = function(clouds, language = 'ru') {
    window.cloudDecoder.setLanguage(language);
    return window.cloudDecoder.decodeCloudiness(clouds);
};

window.parseCloudStringFromMETAR = function(metarString) {
    return window.cloudDecoder.parseCloudStringFromMETAR(metarString);
};

console.log('✅ Cloud decoder initialized with prepositions support');
console.log('🌤️ Available functions: decodeCloudiness(), parseCloudStringFromMETAR()');
</script>

<!-- ========== КОНЕЦ ИСПРАВЛЕННОГО БЛОКА 6A ========== --> <!-- ========== ИСПРАВЛЕННЫЙ БЛОК 6B-1: ИНТЕГРАЦИЯ С ПРЕДЛОГАМИ И ВНГО ========== -->

<script>
// ========== ИНТЕГРАЦИЯ ДЕКОДИРОВЩИКА ОБЛАЧНОСТИ С ПРЕДЛОГАМИ ==========

// ОБНОВЛЕННАЯ функция обновления отображения погоды с декодировщиком облачности
function updateWeatherDisplay(data) {
  if (!data) return;

  console.log('🌤️ Updating weather display with cloud decoder:', data);

  // Обновляем код METAR
  document.getElementById('metarCode').textContent = data.raw;

  // ДАВЛЕНИЕ QNH (код остается тот же)
  if (data.pressure && data.pressure > 0) {
    const pressure = convertPressure(data.pressure);
    const allWeatherRows = document.querySelectorAll('.weather-row');
    let hpaField = null, mmhgField = null, inhgField = null;
    let tempField = null, dewField = null;

    allWeatherRows.forEach((row) => {
      const label = row.querySelector('.section-label');
      const value = row.querySelector('.data-value');
      const units = row.querySelector('.units');

      if (!value || !units) return;

      const labelText = label ? label.textContent.trim() : '';
      const unitsText = units.textContent.trim();

      if (unitsText === 'hPa' && !hpaField) {
        hpaField = value;
      } else if (unitsText === 'mmHg' && !mmhgField) {
        mmhgField = value;
      } else if (unitsText === 'inHg' && !inhgField) {
        inhgField = value;
      } else if (unitsText === '°C' && labelText === 'T' && !tempField) {
        tempField = value;
      } else if (unitsText === '°C' && labelText === 'DP' && !dewField) {
        dewField = value;
      }
    });

    if (hpaField) hpaField.textContent = pressure.hpa;
    if (mmhgField) mmhgField.textContent = pressure.mmhg;
    if (inhgField) inhgField.textContent = pressure.inhg;
    if (tempField) tempField.textContent = data.temperature !== null ? data.temperature : '-';
    if (dewField) dewField.textContent = data.dewpoint !== null ? data.dewpoint : '-';

  } else {
    document.querySelectorAll('.weather-row').forEach(row => {
      const units = row.querySelector('.units');
      const value = row.querySelector('.data-value');
      if (units && value && ['hPa', 'mmHg', 'inHg'].includes(units.textContent.trim())) {
        value.textContent = '-';
      }
    });
  }

  // Видимость MOR
  const visEl = document.querySelector('#morLabel').parentElement.querySelector('.data-value');
  if (visEl) {
    visEl.textContent = data.visibility || '-';
  }

  // ВЕТЕР
  const windDir = data.wind.calm ? 0 : data.wind.direction;
  const windSpeed = data.wind.calm ? 0 : data.wind.speed;

  document.querySelectorAll('.wind-direction').forEach(el => {
    el.textContent = data.wind.calm ? '---°' : `${windDir.toString().padStart(3, '0')}°`;
  });

  document.querySelectorAll('.wind-speed').forEach(el => {
    el.textContent = windSpeed.toString();
  });

  // ========== НОВОЕ: УЛУЧШЕННОЕ ДЕКОДИРОВАНИЕ ОБЛАЧНОСТИ С ПРЕДЛОГАМИ ==========
  const currentLanguage = document.getElementById('language').value === 'ru' ? 'ru' : 'en';

  // Декодируем облачность с помощью нового декодировщика
  const decodedClouds = decodeCloudiness(data.clouds, currentLanguage);
  console.log('☁️ Decoded clouds with prepositions:', decodedClouds);

  // Обновляем отображение облачности С ПРЕДЛОГАМИ И HTML ПЕРЕНОСАМИ
  const skyEl = document.querySelector('#skyConditionLabel').parentElement.querySelector('.data-value');
  if (skyEl) {
    skyEl.innerHTML = decodedClouds.summary; // ИЗМЕНЕНО: используем innerHTML для <br>
    console.log(`☁️ Sky condition with prepositions and line breaks: ${decodedClouds.summary}`);
  }

  // ========== ИСПРАВЛЕННОЕ ОТОБРАЖЕНИЕ ВНГО (САМАЯ НИЖНЯЯ ОБЛАЧНОСТЬ) В ФУТАХ ==========
  const cloudBaseEl = document.querySelector('#qbbLabel').parentElement.querySelector('.data-value');
  const cloudBaseUnitsEl = document.querySelector('#qbbLabel').parentElement.querySelector('.units');
  if (cloudBaseEl && cloudBaseUnitsEl) {
    let cloudBaseText = '-';

    // Ищем САМЫЙ НИЗКИЙ слой облаков (любой тип) для ВНГО
    const lowestCloudLayer = decodedClouds.layers
      .filter(layer => layer.height && layer.height > 0 &&
                      ['BKN', 'OVC', 'SCT', 'FEW'].includes(layer.coverageCode))
      .sort((a, b) => a.height - b.height)[0];

    if (lowestCloudLayer) {
      cloudBaseText = lowestCloudLayer.height.toString();
      console.log(`☁️ Lowest cloud base (ВНГО): ${cloudBaseText} feet`);
    } else if (decodedClouds.layers.length > 0) {
      // Если есть облачность но нет измеримой высоты (например SKC, CLR)
      const specialLayer = decodedClouds.layers.find(layer => layer.special);
      if (specialLayer && ['SKC', 'CLR', 'NSC', 'NCD'].some(code => specialLayer.code.includes(code))) {
        cloudBaseText = currentLanguage === 'ru' ? 'Ясно' : 'Clear';
        console.log(`☁️ Clear skies (ВНГО): ${cloudBaseText}`);
      } else if (specialLayer && specialLayer.code.includes('VV')) {
        // Для вертикальной видимости показываем высоту
        cloudBaseText = specialLayer.height ? specialLayer.height.toString() : 'VV';
        console.log(`☁️ Vertical visibility (ВНГО): ${cloudBaseText}`);
      }
    }

    cloudBaseEl.textContent = cloudBaseText;

    // ИСПРАВЛЕНО: Устанавливаем единицы для ВНГО в футах
    cloudBaseUnitsEl.textContent = currentLanguage === 'ru' ? 'фт' : 'ft';
  }

  // ========== НОВОЕ: ИЗВЛЕЧЕНИЕ QBB ИЗ РЕМАРОК ==========
  const qbbFromRemarks = extractQBBFromRemarks(data.raw, currentLanguage);
  if (qbbFromRemarks !== null) {
    // Если найден QBB в ремарках, заменяем ВНГО на QBB
    if (cloudBaseEl && cloudBaseUnitsEl) {
      cloudBaseEl.textContent = qbbFromRemarks.toString();
      cloudBaseUnitsEl.textContent = currentLanguage === 'ru' ? 'м' : 'm'; // QBB всегда в метрах
      console.log(`☁️ QBB from remarks: ${qbbFromRemarks} meters (overrides ВНГО)`);
    }
  }

  // ДЕКОДИРОВАНИЕ ПОГОДНЫХ ЯВЛЕНИЙ (остается тот же)
  const weatherEl = document.getElementById('weatherPhenomena');
  if (weatherEl) {
    if (data.weather && data.weather.length > 0) {
      const decodedWeather = data.weather.map(weatherCode => {
        let decoded;
        if (weatherHybridDictionary[weatherCode]) {
          decoded = weatherHybridDictionary[weatherCode][currentLanguage];
        } else {
          decoded = decodeWeatherComponentAnalysis(weatherCode, currentLanguage);
          decoded = decoded || weatherCode;
        }
        return decoded;
      });

      const finalWeatherText = formatWeatherList(decodedWeather);
      weatherEl.textContent = finalWeatherText;

    } else {
      weatherEl.textContent = '-';
    }
  }

  // Остальные обновления
  updateSunriseSunset();
  if (currentRunwayData) {
    initializeCompass('compass');
    initializeCompass('compass2');
    updateWindComponents();
  }
  updateQFEForSelectedRunways();

  console.log('✅ Weather display updated with cloud decoding and prepositions');
}
</script>

<!-- ========== КОНЕЦ ИСПРАВЛЕННОГО БЛОКА 6B-1 ========== --><!-- ========== ИСПРАВЛЕННЫЙ БЛОК 6B-2A: ПОЛНЫЙ ПАРСЕР METAR - ТОЛЬКО ОСНОВНАЯ ЧАСТЬ ========== -->

<script>
// ========== НОВАЯ ФУНКЦИЯ ИЗВЛЕЧЕНИЯ ТОЛЬКО ОСНОВНОЙ ЧАСТИ METAR ==========

function extractMainMETARPart(metarString) {
    if (!metarString) return '';

    let mainPart = metarString.trim();

    console.log('🔧 Extracting MAIN METAR part from:', metarString);

    // 1. Удаляем ремарки RMK - все после "RMK"
    const rmkIndex = mainPart.indexOf(' RMK ');
    if (rmkIndex !== -1) {
        mainPart = mainPart.substring(0, rmkIndex);
        console.log('✂️ Cut RMK section');
    }

    // 2. Удаляем прогнозы TEMPO - все после "TEMPO"
    const tempoIndex = mainPart.indexOf(' TEMPO ');
    if (tempoIndex !== -1) {
        mainPart = mainPart.substring(0, tempoIndex);
        console.log('✂️ Cut TEMPO section');
    }

    // 3. Удаляем прогнозы BECMG - все после "BECMG"
    const becmgIndex = mainPart.indexOf(' BECMG ');
    if (becmgIndex !== -1) {
        mainPart = mainPart.substring(0, becmgIndex);
        console.log('✂️ Cut BECMG section');
    }

    // 4. Удаляем прогнозы PROB - все после "PROB"
    const probIndex = mainPart.indexOf(' PROB');
    if (probIndex !== -1) {
        mainPart = mainPart.substring(0, probIndex);
        console.log('✂️ Cut PROB section');
    }

    // 5. Удаляем окончание знак "="
    mainPart = mainPart.replace(/\s*=\s*$/, '');

    // 6. Убираем лишние пробелы
    mainPart = mainPart.replace(/\s+/g, ' ').trim();

    console.log('✅ Main METAR part extracted:', mainPart);
    return mainPart;
}

// ========== ИСПРАВЛЕННЫЙ ПАРСЕР METAR - ТОЛЬКО ОСНОВНАЯ ЧАСТЬ ==========

function parseMetar(metarString) {
    if (!metarString) return null;

    console.log('🌦️ Parsing METAR (FIXED - main part only):', metarString);

    // ИСПРАВЛЕНО: Извлекаем ТОЛЬКО основную часть METAR
    const mainMETAR = extractMainMETARPart(metarString);
    console.log('🎯 Processing ONLY main METAR part:', mainMETAR);

    const parts = mainMETAR.split(' ');
    const data = {
        raw: metarString, // Сохраняем оригинальный METAR для отображения
        icao: parts[0],
        time: '',
        wind: { direction: 0, speed: 0, gust: 0, variable: false, calm: false },
        visibility: 0,
        weather: [],
        clouds: [],
        temperature: null,
        dewpoint: null,
        pressure: null
    };

    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];

        // Время
        if (part.match(/^\d{6}Z$/)) {
            data.time = part;
            console.log(`🕐 Time: ${part}`);
        }

        // Ветер
        const windMatch = part.match(/^(\d{3})(\d{2,3})(G(\d{2,3}))?(KT|MPS)$/);
        if (windMatch) {
            data.wind.direction = parseInt(windMatch[1]);
            data.wind.speed = parseInt(windMatch[2]);
            data.wind.gust = windMatch[4] ? parseInt(windMatch[4]) : 0;

            if (windMatch[5] === 'MPS') {
                data.wind.speed = Math.round(data.wind.speed * 1.944);
                if (data.wind.gust > 0) {
                    data.wind.gust = Math.round(data.wind.gust * 1.944);
                }
            }

            console.log(`💨 Wind: ${data.wind.direction}°/${data.wind.speed}kt (gust: ${data.wind.gust})`);
        }

        // Штиль
        if (part === '00000KT' || part === '00000MPS') {
            data.wind.calm = true;
            console.log('💨 Wind: CALM');
        }

        // Переменный ветер
        if (part.match(/^\d{3}V\d{3}$/)) {
            data.wind.variable = true;
            console.log('💨 Wind: VARIABLE');
        }

        // Видимость
        if (part.match(/^\d{4}$/) && parseInt(part) >= 100) {
            data.visibility = parseInt(part);
            console.log(`👁️ Visibility: ${data.visibility}m`);
        }

        // CAVOK
        if (part === 'CAVOK') {
            data.visibility = 10000;
            console.log('👁️ Visibility: CAVOK (10000m)');
        }

        // Температура и точка росы
        const tempMatch = part.match(/^(M?\d{1,2})\/(M?\d{1,2})$/);
        if (tempMatch) {
            let tempStr = tempMatch[1];
            let dewStr = tempMatch[2];

            if (tempStr.startsWith('M')) {
                data.temperature = -parseInt(tempStr.substring(1));
            } else {
                data.temperature = parseInt(tempStr);
            }

            if (dewStr.startsWith('M')) {
                data.dewpoint = -parseInt(dewStr.substring(1));
            } else {
                data.dewpoint = parseInt(dewStr);
            }

            console.log(`🌡️ Temperature: ${data.temperature}°C, Dewpoint: ${data.dewpoint}°C`);
        }

        // Давление QNH
        if (part.startsWith('Q') && part.length >= 5) {
            const qnhMatch = part.match(/Q(\d{4})/);
            if (qnhMatch) {
                const pressureValue = parseInt(qnhMatch[1]);
                data.pressure = pressureValue;
                console.log(`✅ PRESSURE: ${part} → ${data.pressure} hPa`);
            }
        }

        if (part.startsWith('A') && part.length >= 5) {
            const altimeterMatch = part.match(/A(\d{4})/);
            if (altimeterMatch) {
                const inchesHg = parseInt(altimeterMatch[1]) / 100;
                data.pressure = Math.round(inchesHg / 0.02953);
                console.log(`✅ PRESSURE: ${part} → ${inchesHg}" Hg = ${data.pressure} hPa`);
            }
        }

        // Специальные коды облачности - ТОЛЬКО из основной части
        if (['SKC', 'CLR', 'NSC', 'NCD', 'CAVOK'].includes(part)) {
            data.clouds.push(part);
            console.log(`☁️ Special cloud code: ${part}`);
            continue;
        }

        // Вертикальная видимость - ТОЛЬКО из основной части
        if (part.match(/^VV\d{3}$/)) {
            data.clouds.push(part);
            console.log(`☁️ Vertical visibility: ${part}`);
            continue;
        }

        // Обычные слои облаков - ТОЛЬКО из основной части
        const cloudMatch = part.match(/^(FEW|SCT|BKN|OVC)(\d{3})(CB|TCU|CBMAM)?$/);
        if (cloudMatch) {
            const coverage = cloudMatch[1];
            const height = parseInt(cloudMatch[2]) * 100;
            const type = cloudMatch[3] || null;

            data.clouds.push({
                coverage: coverage,
                height: height,
                type: type
            });

            console.log(`☁️ Cloud layer: ${coverage} at ${height}ft${type ? ` (${type})` : ''}`);
            continue;
        }

        // Неопределенная облачность - ТОЛЬКО из основной части
        if (part === '///') {
            data.clouds.push(part);
            console.log('☁️ Undefined cloud data: ///');
            continue;
        }

        // Погодные явления - ТОЛЬКО из основной части
        if (isWeatherPhenomenon(part)) {
            data.weather.push(part);
            console.log(`🌧️ Weather phenomenon: ${part}`);
        }
    }

    if (data.pressure === null || data.pressure === 0) {
        console.error(`❌ NO PRESSURE FOUND IN MAIN METAR PART: "${mainMETAR}"`);
    } else {
        console.log(`🎯 PRESSURE FROM MAIN PART: ${data.pressure} hPa`);
    }

    console.log('🎯 Final parsed data (main part only):', {
        icao: data.icao,
        pressure: data.pressure,
        temperature: data.temperature,
        dewpoint: data.dewpoint,
        visibility: data.visibility,
        weather: data.weather,
        clouds: data.clouds.length,
        wind: `${data.wind.direction}°/${data.wind.speed}kt`
    });

    return data;
}

// Функция определения погодных явлений (без изменений)
function isWeatherPhenomenon(part) {
    if (!part || part.length < 2) return false;

    // СТРОГО исключаем все, что НЕ является текущими погодными явлениями
    if (part.match(/^\d{4}Z?$/)) return false; // время
    if (part.match(/^[A-Z]{4}$/)) return false; // ICAO коды аэропортов
    if (part.match(/^Q\d{4}$/)) return false; // давление QNH
    if (part.match(/^A\d{4}$/)) return false; // давление в дюймах
    if (part.match(/^M?\d{2}\/M?\d{2}$/)) return false; // температура/точка росы
    if (part.match(/^\d{3}\d{2}(G\d{2})?KT$/)) return false; // ветер направление/скорость
    if (part.match(/^\d{3}V\d{3}$/)) return false; // переменный ветер
    if (part.match(/^00000KT$/)) return false; // штиль
    if (part.match(/^(FEW|SCT|BKN|OVC)\d{3}(CB|TCU|CBMAM)?$/)) return false; // облачность
    if (part.match(/^VV\d{3}$/)) return false; // вертикальная видимость
    if (part.match(/^R\d{2}[LRC]?\/\d{4}(V\d{4})?(FT)?[UDN]?$/)) return false; // RVR
    if (part.match(/^\d{4}$/)) return false; // видимость в метрах
    if (part.match(/^\d{1,2}SM$/)) return false; // видимость в милях

    // Исключаем служебные коды
    if (['SKC', 'CLR', 'NSC', 'NCD', 'CAVOK', 'NOSIG', 'AUTO', 'COR'].includes(part)) return false;

    // ТОЛЬКО текущие погодные явления - проверяем строго по стандарту WMO
    if (part.match(/^[-+VC](MI|PR|BC|DR|BL|SH|TS|FZ)?(DZ|RA|SN|SG|IC|PL|GR|GS|UP|BR|FG|FU|VA|DU|SA|HZ|PY|SQ|FC|SS|DS|PO)+$/)) return true;
    if (part.match(/^(MI|PR|BC|DR|BL|SH|TS|FZ)(DZ|RA|SN|SG|IC|PL|GR|GS|UP|BR|FG|FU|VA|DU|SA|HZ|PY|SQ|FC|SS|DS|PO)+$/)) return true;
    if (part.match(/^(DZ|RA|SN|SG|IC|PL|GR|GS|UP|BR|FG|FU|VA|DU|SA|HZ|PY|SQ|FC|SS|DS|PO)+$/)) return true;
    if (part.match(/^[-+](DZ|RA|SN|SG|IC|PL|GR|GS|UP|BR|FG|FU|VA|DU|SA|HZ|PY|SQ|FC|SS|DS|PO)+$/)) return true;

    return false;
}

console.log('✅ METAR parser fixed - only main part processed for weather and clouds');
</script>

<!-- ========== КОНЕЦ ИСПРАВЛЕННОГО БЛОКА 6B-2A ==========><!-- ========== ИСПРАВЛЕННЫЙ БЛОК 6B-2B: ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ========== -->

<script>
// ========== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЕКОДИРОВЩИКА ==========

// УПРОЩЕННАЯ функция компонентного анализа
function decodeWeatherComponentAnalysis(weatherCode, language = 'ru') {
  if (!weatherCode || weatherCode.trim() === '') return '';

  const code = weatherCode.trim().toUpperCase();
  let remainingCode = code;
  const decodedParts = [];

  // 1. Проверяем интенсивность
  if (remainingCode.startsWith('-')) {
    const intensityText = weatherIntensityMap['-'][language];
    decodedParts.push(intensityText.toLowerCase());
    remainingCode = remainingCode.substring(1);
  } else if (remainingCode.startsWith('+')) {
    const intensityText = weatherIntensityMap['+'][language];
    decodedParts.push(intensityText.toLowerCase());
    remainingCode = remainingCode.substring(1);
  } else if (remainingCode.startsWith('VC')) {
    const vicinityText = weatherDescriptorMap['VC'][language];
    decodedParts.push(vicinityText.toLowerCase());
    remainingCode = remainingCode.substring(2);
  }

  // 2. Проверяем дескрипторы
  for (const [descriptor, translations] of Object.entries(weatherDescriptorMap)) {
    if (descriptor !== 'VC' && remainingCode.startsWith(descriptor)) {
      decodedParts.push(translations[language].toLowerCase());
      remainingCode = remainingCode.substring(descriptor.length);
      break;
    }
  }

  // 3. Парсим оставшиеся явления
  const foundPhenomena = [];
  while (remainingCode.length >= 2) {
    let found = false;

    // Проверяем двухбуквенные коды
    for (const [phenomCode, translations] of Object.entries(weatherPhenomenaMap)) {
      if (remainingCode.startsWith(phenomCode)) {
        foundPhenomena.push(translations[language]);
        remainingCode = remainingCode.substring(phenomCode.length);
        found = true;
        break;
      }
    }

    if (!found) break;
  }

  // 4. Собираем результат
  if (foundPhenomena.length > 0) {
    if (foundPhenomena.length === 1) {
      decodedParts.push(foundPhenomena[0]);
    } else {
      // Несколько явлений - соединяем через "и"/"and"
      const conjunction = language === 'ru' ? ' и ' : ' and ';
      const combinedPhenomena = foundPhenomena.join(conjunction);
      decodedParts.push(combinedPhenomena);
    }
  }

  const result = decodedParts.join(' ');
  return result || code;
}

// Функция форматирования текста погоды
function formatWeatherText(text) {
  if (!text || text.trim() === '') return '';

  const trimmed = text.trim();
  return trimmed.charAt(0).toUpperCase() + trimmed.slice(1).toLowerCase();
}

// Функция форматирования всего списка погодных явлений
function formatWeatherList(weatherArray) {
  if (!weatherArray || weatherArray.length === 0) return '';

  const formattedList = weatherArray.map((weather, index) => {
    if (index === 0) {
      return formatWeatherText(weather);
    } else {
      return weather.trim().toLowerCase();
    }
  }).join(', ');

  return formattedList;
}

// ОБНОВЛЕННАЯ функция очистки данных с учетом нового декодировщика облачности
function clearAllWeatherData() {
  document.querySelectorAll('.weather-row .data-value').forEach(el => {
    if (!el.classList.contains('pressure-secondary')) {
      el.textContent = '-';
    }
  });
  document.querySelectorAll('.pressure-secondary').forEach(el => el.textContent = '-');

  // Очищаем погодные явления
  const weatherEl = document.getElementById('weatherPhenomena');
  if (weatherEl) {
    weatherEl.textContent = '-';
  }

  // Очищаем облачность
  document.querySelector('#skyConditionLabel').parentElement.querySelector('.data-value').textContent = '-';

  // Очищаем нижнюю границу облачности и сбрасываем единицы
  const qbbEl = document.querySelector('#qbbLabel').parentElement.querySelector('.data-value');
  const qbbUnitsEl = document.querySelector('#qbbLabel').parentElement.querySelector('.units');
  if (qbbEl) qbbEl.textContent = '-';
  if (qbbUnitsEl) qbbUnitsEl.textContent = 'м'; // По умолчанию метры для QBB

  document.getElementById('metarCode').textContent = '-';

  document.querySelectorAll('.lateral-component .data-value').forEach(el => el.textContent = '-');
  document.querySelectorAll('.headwind-component .data-value').forEach(el => el.textContent = '-');
  document.querySelectorAll('.friction-coefficient .data-value').forEach(el => el.textContent = '-');

  document.querySelectorAll('.wind-direction').forEach(el => el.textContent = '---°');
  document.querySelectorAll('.wind-speed').forEach(el => el.textContent = '-');

  document.querySelectorAll('.compass-info .rvr-row .data-value').forEach(el => el.textContent = '-');
  document.querySelectorAll('.qfe-row, .elev-row').forEach(row => row.remove());
  document.querySelectorAll('.forecast-value').forEach(el => el.textContent = '-');

  // Очищаем данные восхода/захода
  document.getElementById('sunrise').textContent = '-';
  document.getElementById('sunset').textContent = '-';
  window.airportData = null;

  console.log('🧹 All weather data cleared including enhanced cloud data');
}

// ОБНОВЛЕННАЯ функция применения языка с поддержкой декодировщика облачности
function applyLanguage(lang) {
  // Обновляем все текстовые метки
  if (lang === 'ru') {
    document.getElementById('timeLabel').textContent = 'Время UTC';
    document.getElementById('sunriseLabel').textContent = 'Восход';
    document.getElementById('sunsetLabel').textContent = 'Заход';
    document.getElementById('weatherLabel').textContent = 'Явления погоды';
    document.getElementById('morLabel').textContent = 'Видимость';
    document.getElementById('qbbLabel').textContent = 'ВНГО';
    document.getElementById('skyConditionLabel').textContent = 'Облачность';
    document.getElementById('forecastLabel').textContent = 'Прогноз погоды';
    document.getElementById('specialLabel').textContent = 'Особые условия';
    document.getElementById('lateralLabel1').textContent = 'Боковая';
    document.getElementById('headwindLabel1').textContent = 'Встречная';
    document.getElementById('frictionLabel1').textContent = 'КСц';
    document.getElementById('lateralLabel2').textContent = 'Боковая';
    document.getElementById('headwindLabel2').textContent = 'Встречная';
    document.getElementById('frictionLabel2').textContent = 'КСц';

    // ИСПРАВЛЯЕМ ЕДИНИЦЫ ДЛЯ ВИДИМОСТИ В РУССКОМ
    const morUnits = document.querySelector('#morLabel').parentElement.querySelector('.units');
    if (morUnits) morUnits.textContent = 'м';

  } else {
    document.getElementById('timeLabel').textContent = 'Time UTC';
    document.getElementById('sunriseLabel').textContent = 'Sunrise';
    document.getElementById('sunsetLabel').textContent = 'Sunset';
    document.getElementById('weatherLabel').textContent = 'Weather';
    document.getElementById('morLabel').textContent = 'Visibility'; // ИСПРАВЛЕНО: MOR → Visibility
    document.getElementById('qbbLabel').textContent = 'QBB';
    document.getElementById('skyConditionLabel').textContent = 'Sky condition';
    document.getElementById('forecastLabel').textContent = 'Weather forecast';
    document.getElementById('specialLabel').textContent = 'Special conditions';
    document.getElementById('lateralLabel1').textContent = 'Side';
    document.getElementById('headwindLabel1').textContent = 'Head';
    document.getElementById('frictionLabel1').textContent = 'Breaking action';
    document.getElementById('lateralLabel2').textContent = 'Side';
    document.getElementById('headwindLabel2').textContent = 'Head';
    document.getElementById('frictionLabel2').textContent = 'Breaking action';

    // ИСПРАВЛЯЕМ ЕДИНИЦЫ ДЛЯ ВИДИМОСТИ В АНГЛИЙСКОМ
    const morUnits = document.querySelector('#morLabel').parentElement.querySelector('.units');
    if (morUnits) morUnits.textContent = 'm'; // ИСПРАВЛЕНО: м → m
  }

  // ПЕРЕКОДИРУЕМ ПОГОДНЫЕ ЯВЛЕНИЯ И ОБЛАЧНОСТЬ ПРИ СМЕНЕ ЯЗЫКА
  if (currentMetarData) {
    console.log('🔄 Re-decoding weather and clouds for language change:', lang);
    updateWeatherDisplay(currentMetarData);
  }
}

console.log('✅ Enhanced cloud decoder integration completed with forecast filtering');

// НОВАЯ функция для извлечения QBB из ремарок METAR
function extractQBBFromRemarks(metarString, language = 'ru') {
  if (!metarString) return null;

  // Ищем секцию RMK в METAR
  const rmkIndex = metarString.indexOf(' RMK ');
  if (rmkIndex === -1) return null;

  const remarksSection = metarString.substring(rmkIndex + 5); // +5 для ' RMK '
  console.log('🔍 Searching for QBB in remarks:', remarksSection);

  // Ищем паттерны QBB в ремарках
  // Возможные форматы: QBB150, QBB 150, QBB=150 и т.д.
  const qbbPattern = /QBB[=\s]?(\d{3,4})/i;
  const qbbMatch = remarksSection.match(qbbPattern);

  if (qbbMatch) {
    const qbbValue = parseInt(qbbMatch[1]);
    console.log(`✅ Found QBB in remarks: ${qbbValue} meters`);
    return qbbValue;
  }

  // Альтернативные паттерны для QBB
  const altPatterns = [
    /CLD BASE[=\s]?(\d{3,4})/i,
    /CLOUD BASE[=\s]?(\d{3,4})/i,
    /CB[=\s]?(\d{3,4})/i,
    /ВНГО[=\s]?(\d{3,4})/i
  ];

  for (const pattern of altPatterns) {
    const match = remarksSection.match(pattern);
    if (match) {
      const qbbValue = parseInt(match[1]);
      console.log(`✅ Found alternative QBB pattern in remarks: ${qbbValue} meters`);
      return qbbValue;
    }
  }

  console.log('❌ No QBB found in remarks');
  return null;
}

// НОВАЯ функция для тестирования фильтрации прогнозов
window.testMETARFiltering = function(metarString = 'UUEE 121200Z 27008G15KT 9999 FEW020 SCT080 BKN200 12/08 Q1013 TEMPO 1215/1218 4000 -RA BKN010 BECMG 1218/1221 27015KT CAVOK RMK QBB120 TEST') {
  console.log('🧪 Testing METAR forecast filtering...');
  console.log('📥 Original:', metarString);

  const filtered = filterMETARForCurrentConditions(metarString);
  console.log('🔧 Filtered:', filtered);

  const parsed = parseMetar(metarString);
  console.log('📊 Parsed weather phenomena:', parsed.weather);
  console.log('☁️ Parsed clouds:', parsed.clouds);

  // Тестируем извлечение QBB
  const qbb = extractQBBFromRemarks(metarString);
  console.log('🏢 Extracted QBB:', qbb);

  return { original: metarString, filtered: filtered, parsed: parsed, qbb: qbb };
};

// НОВАЯ функция для тестирования отображения облачности с предлогами и переносами
window.testCloudDisplayWithPrepositions = function(language = 'ru') {
  console.log(`🧪 Testing cloud display with prepositions and line breaks (${language})...`);

  const testClouds = [
    { coverage: 'FEW', height: 1000 },
    { coverage: 'SCT', height: 2500 },
    { coverage: 'BKN', height: 8000, type: 'TCU' }
  ];

  window.cloudDecoder.setLanguage(language);
  const decoded = window.cloudDecoder.decodeCloudiness(testClouds);

  console.log('☁️ Cloud summary with prepositions and line breaks:', decoded.summary);
  console.log('📋 Layer details:', decoded.layers.map(l => `${l.coverage} ${l.heightText}${l.type ? ` (${l.type})` : ''}`));

  return decoded;
};

// НОВАЯ функция для тестирования QBB из ремарок
window.testQBBExtraction = function(metarString = 'UUEE 121200Z 27008KT 9999 FEW020 12/08 Q1013 RMK QBB150 A2991') {
  console.log('🧪 Testing QBB extraction from remarks...');
  console.log('📥 METAR:', metarString);

  const qbbRu = extractQBBFromRemarks(metarString, 'ru');
  const qbbEn = extractQBBFromRemarks(metarString, 'en');

  console.log('🏢 QBB (RU):', qbbRu);
  console.log('🏢 QBB (EN):', qbbEn);

  return { metar: metarString, qbbRu: qbbRu, qbbEn: qbbEn };
};
</script>

<!-- ========== КОНЕЦ ИСПРАВЛЕННОГО БЛОКА 6B-2B ========== -->

</body>
</html>
